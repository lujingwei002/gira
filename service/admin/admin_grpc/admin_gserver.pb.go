// Code generated by protoc-gen-go-gserver. DO NOT EDIT.
// versions:
// - protoc-gen-go-gserver v1.3.0
// - protoc             v3.12.4
// source: service/admin/admin.proto

package admin_grpc

import (
	context "context"
	gira "github.com/lujingwei002/gira"
	errors "github.com/lujingwei002/gira/errors"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	metadata "google.golang.org/grpc/metadata"
	status "google.golang.org/grpc/status"
	sync "sync"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// AdminServerRouter is the default server router handler for Admin service.
type AdminServerRouterHandler interface {
	AdminServer
}

// AdminServerRouter is the default server router middleware for Admin service.
type AdminServerRouterMiddleware interface {
	AdminServerRouterMiddlewareInvoke(ctx AdminServerRouterMiddlewareContext) error
}

// AdminServerRouter is the default server router middleware context for Admin service.
type AdminServerRouterMiddlewareContext interface {
	Next()
	Wait() error
}

type adminServerRouterMiddlewareContext struct {
	handler    func() (resp interface{}, err error)
	ctx        context.Context
	fullMethod string
	in         interface{}
	out        interface{}
	err        error
	method     string
	c          chan struct{}
}

func (m *adminServerRouterMiddlewareContext) Next() {
	defer func() {
		if e := recover(); e != nil {
			m.err = e.(error)
		}
	}()
	m.out, m.err = m.handler()
	if m.c != nil {
		m.c <- struct{}{}
	}
}
func (m *adminServerRouterMiddlewareContext) Wait() error {
	if m.c == nil {
		m.c = make(chan struct{}, 1)
	}
	select {
	case <-m.c:
		return nil
	case <-m.ctx.Done():
		m.err = m.ctx.Err()
		return m.err
	}
}

// AdminServerRouter is the default server router for Admin service.
type AdminServerRouter interface {
	RegisterHandler(key string, handler AdminServerRouterHandler)
	RegisterMiddleware(key string, middle AdminServerRouterMiddleware)
	UnregisterHandler(key string, handler AdminServerRouterHandler)
}

// adminServerRouter is the default server router for Admin service.
type adminServerRouter struct {
	UnimplementedAdminServer
	mu          sync.Mutex
	handlers    sync.Map
	middlewares sync.Map
}

func (svr *adminServerRouter) RegisterMiddleware(key string, middleware AdminServerRouterMiddleware) {
	svr.middlewares.Store(key, middleware)
}

func (svr *adminServerRouter) RegisterHandler(key string, handler AdminServerRouterHandler) {
	svr.handlers.Store(key, handler)
}

func (svr *adminServerRouter) UnregisterHandler(key string, handler AdminServerRouterHandler) {
	svr.handlers.Delete(key)
	svr.middlewares.Delete(key)
}

func (svr *adminServerRouter) ReloadResource(ctx context.Context, in *ReloadResourceRequest) (*ReloadResourceResponse, error) {
	var kv metadata.MD
	var ok bool
	if kv, ok = metadata.FromIncomingContext(ctx); !ok {
		if kv, ok = metadata.FromOutgoingContext(ctx); !ok {
			return nil, errors.ErrServerRouterMetaNotFound
		}
	}
	if keys, ok := kv[gira.GRPC_PATH_KEY]; !ok {
		return nil, errors.ErrServerRouterKeyNotFound
	} else if len(keys) <= 0 {
		return nil, errors.ErrServerRouterKeyNotFound
	} else if v, ok := svr.handlers.Load(keys[0]); !ok {
		return nil, errors.ErrServerRouterHandlerNotRegist
	} else if handler, ok := v.(AdminServer); !ok {
		return nil, errors.ErrServerRouterHandlerNotImplement
	} else {
		if v, ok := svr.middlewares.Load(keys[0]); !ok {
			return handler.ReloadResource(ctx, in)
		} else if middleware, ok := v.(AdminServerRouterMiddleware); ok {
			r := &adminServerRouterMiddlewareContext{
				fullMethod: Admin_ReloadResource_FullMethodName,
				method:     "ReloadResource",
				ctx:        ctx,
				in:         in,
				handler: func() (resp interface{}, err error) {
					return handler.ReloadResource(ctx, in)
				},
			}
			if err := middleware.AdminServerRouterMiddlewareInvoke(r); err != nil {
				return nil, err
			}
			if r.out == nil && r.err == nil {
				return nil, errors.ErrServerRouterHandlerNotImplement
			} else if r.out == nil && r.err != nil {
				return nil, r.err
			} else {
				return r.out.(*ReloadResourceResponse), r.err
			}
		} else {
			return handler.ReloadResource(ctx, in)
		}
	}
}
func (svr *adminServerRouter) ReloadResource1(s Admin_ReloadResource1Server) error {
	return status.Errorf(codes.Unimplemented, "method ReloadResource1 not implemented")
}
func (svr *adminServerRouter) ReloadResource2(in *ReloadResourceRequest2, s Admin_ReloadResource2Server) error {
	return status.Errorf(codes.Unimplemented, "method ReloadResource2 not implemented")
}
func (svr *adminServerRouter) ReloadResource3(s Admin_ReloadResource3Server) error {
	return status.Errorf(codes.Unimplemented, "method ReloadResource3 not implemented")
}

func RegisterAdminServerAsRouter(s grpc.ServiceRegistrar, handler AdminServerRouterHandler) AdminServerRouter {
	svr := &adminServerRouter{}
	s.RegisterService(&Admin_ServiceRouterDesc, svr)
	return svr
}

func _Admin_ReloadResource_RouterHandler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReloadResourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).ReloadResource(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Admin_ReloadResource_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).ReloadResource(ctx, req.(*ReloadResourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_ReloadResource1_RouterHandler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(AdminServer).ReloadResource1(&adminReloadResource1ServerRouter{stream})
}

type Admin_ReloadResource1ServerRouter interface {
	SendAndClose(*ReloadResourceResponse1) error
	Recv() (*ReloadResourceRequest1, error)
	grpc.ServerStream
}

type adminReloadResource1ServerRouter struct {
	grpc.ServerStream
}

func (x *adminReloadResource1ServerRouter) SendAndClose(m *ReloadResourceResponse1) error {
	return x.ServerStream.SendMsg(m)
}

func (x *adminReloadResource1ServerRouter) Recv() (*ReloadResourceRequest1, error) {
	m := new(ReloadResourceRequest1)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Admin_ReloadResource2_RouterHandler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ReloadResourceRequest2)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AdminServer).ReloadResource2(m, &adminReloadResource2ServerRouter{stream})
}

type Admin_ReloadResource2ServerRouter interface {
	Send(*ReloadResourceResponse2) error
	grpc.ServerStream
}

type adminReloadResource2ServerRouter struct {
	grpc.ServerStream
}

func (x *adminReloadResource2ServerRouter) Send(m *ReloadResourceResponse2) error {
	return x.ServerStream.SendMsg(m)
}

func _Admin_ReloadResource3_RouterHandler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(AdminServer).ReloadResource3(&adminReloadResource3ServerRouter{stream})
}

type Admin_ReloadResource3ServerRouter interface {
	Send(*ReloadResourceResponse2) error
	Recv() (*ReloadResourceRequest2, error)
	grpc.ServerStream
}

type adminReloadResource3ServerRouter struct {
	grpc.ServerStream
}

func (x *adminReloadResource3ServerRouter) Send(m *ReloadResourceResponse2) error {
	return x.ServerStream.SendMsg(m)
}

func (x *adminReloadResource3ServerRouter) Recv() (*ReloadResourceRequest2, error) {
	m := new(ReloadResourceRequest2)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Admin_ServiceRouterDesc is the grpc.ServiceDesc for Admin service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Admin_ServiceRouterDesc = grpc.ServiceDesc{
	ServiceName: "admin_grpc.Admin",
	HandlerType: (*AdminServerRouter)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ReloadResource",
			Handler:    _Admin_ReloadResource_RouterHandler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ReloadResource1",
			Handler:       _Admin_ReloadResource1_RouterHandler,
			ClientStreams: true,
		},
		{
			StreamName:    "ReloadResource2",
			Handler:       _Admin_ReloadResource2_RouterHandler,
			ServerStreams: true,
		},
		{
			StreamName:    "ReloadResource3",
			Handler:       _Admin_ReloadResource3_RouterHandler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "service/admin/admin.proto",
}
