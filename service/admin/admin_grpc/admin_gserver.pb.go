// Code generated by protoc-gen-go-gserver. DO NOT EDIT.
// versions:
// - protoc-gen-go-gserver v1.3.0
// - protoc             v3.12.4
// source: service/admin/admin.proto

package admin_grpc

import (
	context "context"
	gira "github.com/lujingwei002/gira"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	metadata "google.golang.org/grpc/metadata"
	status "google.golang.org/grpc/status"
	sync "sync"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// AdminCatalogServer is the default catalog server handler for Admin service.
type AdminCatalogServerHandler interface {
	AdminServer
}

// AdminCatalogServer is the default catalog server middleware for Admin service.
type AdminCatalogServerMiddleware interface {
	AdminCatalogServerMiddlewareInvoke(ctx AdminCatalogServerMiddlewareContext) error
}

// AdminCatalogServer is the default catalog server middleware context for Admin service.
type AdminCatalogServerMiddlewareContext interface {
	Next()
	Wait() error
}

type adminCatalogServerMiddlewareContext struct {
	handler    func() (resp interface{}, err error)
	ctx        context.Context
	fullMethod string
	in         interface{}
	out        interface{}
	err        error
	method     string
	c          chan struct{}
}

func (m *adminCatalogServerMiddlewareContext) Next() {
	defer func() {
		if e := recover(); e != nil {
			m.err = e.(error)
		}
	}()
	m.out, m.err = m.handler()
	if m.c != nil {
		m.c <- struct{}{}
	}
}
func (m *adminCatalogServerMiddlewareContext) Wait() error {
	if m.c == nil {
		m.c = make(chan struct{}, 1)
	}
	select {
	case <-m.c:
		return nil
	case <-m.ctx.Done():
		m.err = m.ctx.Err()
		return m.err
	}
}

// AdminCatalogServer is the default catalog server for Admin service.
type AdminCatalogServer interface {
	RegisterHandler(key string, handler AdminCatalogServerHandler)
	RegisterMiddleware(key string, middle AdminCatalogServerMiddleware)
	UnregisterHandler(key string, handler AdminCatalogServerHandler)
}

// adminCatalogServer is the default catalog server for Admin service.
type adminCatalogServer struct {
	UnimplementedAdminServer
	mu          sync.Mutex
	handlers    sync.Map
	middlewares sync.Map
}

func (svr *adminCatalogServer) RegisterMiddleware(key string, middleware AdminCatalogServerMiddleware) {
	svr.middlewares.Store(key, middleware)
}

func (svr *adminCatalogServer) RegisterHandler(key string, handler AdminCatalogServerHandler) {
	svr.handlers.Store(key, handler)
}

func (svr *adminCatalogServer) UnregisterHandler(key string, handler AdminCatalogServerHandler) {
	svr.handlers.Delete(key)
	svr.middlewares.Delete(key)
}

func (svr *adminCatalogServer) ReloadResource(ctx context.Context, in *ReloadResourceRequest) (*ReloadResourceResponse, error) {
	if kv, ok := metadata.FromIncomingContext(ctx); !ok {
		return nil, gira.ErrCatalogServerMetaNotFound
	} else if keys, ok := kv["catalog-key"]; !ok {
		return nil, gira.ErrCatalogServerKeyNotFound
	} else if len(keys) <= 0 {
		return nil, gira.ErrCatalogServerKeyNotFound
	} else if v, ok := svr.handlers.Load(keys[0]); !ok {
		return nil, gira.ErrCatalogServerHandlerNotRegist
	} else if handler, ok := v.(AdminServer); !ok {
		return nil, gira.ErrCatalogServerHandlerNotImplement
	} else {
		if v, ok := svr.middlewares.Load(keys[0]); !ok {
			return handler.ReloadResource(ctx, in)
		} else if middleware, ok := v.(AdminCatalogServerMiddleware); ok {
			r := &adminCatalogServerMiddlewareContext{
				fullMethod: Admin_ReloadResource_FullMethodName,
				method:     "ReloadResource",
				ctx:        ctx,
				in:         in,
				handler: func() (resp interface{}, err error) {
					return handler.ReloadResource(ctx, in)
				},
			}
			if err := middleware.AdminCatalogServerMiddlewareInvoke(r); err != nil {
				return nil, err
			}
			if r.out == nil && r.err == nil {
				return nil, gira.ErrCatalogServerHandlerNotImplement
			} else if r.out == nil && r.err != nil {
				return nil, r.err
			} else {
				return r.out.(*ReloadResourceResponse), r.err
			}
		} else {
			return handler.ReloadResource(ctx, in)
		}
	}
}
func (svr *adminCatalogServer) ReloadResource1(s Admin_ReloadResource1Server) error {
	return status.Errorf(codes.Unimplemented, "method ReloadResource1 not implemented")
}
func (svr *adminCatalogServer) ReloadResource2(in *ReloadResourceRequest2, s Admin_ReloadResource2Server) error {
	return status.Errorf(codes.Unimplemented, "method ReloadResource2 not implemented")
}
func (svr *adminCatalogServer) ReloadResource3(s Admin_ReloadResource3Server) error {
	return status.Errorf(codes.Unimplemented, "method ReloadResource3 not implemented")
}

func RegisterAdminServerAsCatalog(s grpc.ServiceRegistrar, handler AdminCatalogServerHandler) AdminCatalogServer {
	svr := &adminCatalogServer{}
	s.RegisterService(&Admin_ServiceCatalogDesc, svr)
	return svr
}

func _Admin_ReloadResource_CatalogHandler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReloadResourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).ReloadResource(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Admin_ReloadResource_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).ReloadResource(ctx, req.(*ReloadResourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_ReloadResource1_CatalogHandler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(AdminServer).ReloadResource1(&adminReloadResource1CatalogServer{stream})
}

type Admin_ReloadResource1CatalogServer interface {
	SendAndClose(*ReloadResourceResponse1) error
	Recv() (*ReloadResourceRequest1, error)
	grpc.ServerStream
}

type adminReloadResource1CatalogServer struct {
	grpc.ServerStream
}

func (x *adminReloadResource1CatalogServer) SendAndClose(m *ReloadResourceResponse1) error {
	return x.ServerStream.SendMsg(m)
}

func (x *adminReloadResource1CatalogServer) Recv() (*ReloadResourceRequest1, error) {
	m := new(ReloadResourceRequest1)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Admin_ReloadResource2_CatalogHandler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ReloadResourceRequest2)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AdminServer).ReloadResource2(m, &adminReloadResource2CatalogServer{stream})
}

type Admin_ReloadResource2CatalogServer interface {
	Send(*ReloadResourceResponse2) error
	grpc.ServerStream
}

type adminReloadResource2CatalogServer struct {
	grpc.ServerStream
}

func (x *adminReloadResource2CatalogServer) Send(m *ReloadResourceResponse2) error {
	return x.ServerStream.SendMsg(m)
}

func _Admin_ReloadResource3_CatalogHandler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(AdminServer).ReloadResource3(&adminReloadResource3CatalogServer{stream})
}

type Admin_ReloadResource3CatalogServer interface {
	Send(*ReloadResourceResponse2) error
	Recv() (*ReloadResourceRequest2, error)
	grpc.ServerStream
}

type adminReloadResource3CatalogServer struct {
	grpc.ServerStream
}

func (x *adminReloadResource3CatalogServer) Send(m *ReloadResourceResponse2) error {
	return x.ServerStream.SendMsg(m)
}

func (x *adminReloadResource3CatalogServer) Recv() (*ReloadResourceRequest2, error) {
	m := new(ReloadResourceRequest2)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Admin_ServiceCatalogDesc is the grpc.ServiceDesc for Admin service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Admin_ServiceCatalogDesc = grpc.ServiceDesc{
	ServiceName: "admin_grpc.Admin",
	HandlerType: (*AdminCatalogServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ReloadResource",
			Handler:    _Admin_ReloadResource_CatalogHandler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ReloadResource1",
			Handler:       _Admin_ReloadResource1_CatalogHandler,
			ClientStreams: true,
		},
		{
			StreamName:    "ReloadResource2",
			Handler:       _Admin_ReloadResource2_CatalogHandler,
			ServerStreams: true,
		},
		{
			StreamName:    "ReloadResource3",
			Handler:       _Admin_ReloadResource3_CatalogHandler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "service/admin/admin.proto",
}
