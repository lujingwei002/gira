// Copyright 2018 The gRPC Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// This file defines an interface for exporting monitoring information
// out of gRPC servers.  See the full design at
// https://github.com/grpc/proposal/blob/master/A14-channelz.md
//
// The canonical version of this proto can be found at
// https://github.com/grpc/grpc-proto/blob/master/grpc/channelz/v1/channelz.proto

// Code generated by protoc-gen-go-gclient. DO NOT EDIT.
// versions:
// - protoc-gen-go-gclient v1.3.0
// - protoc             v3.12.4
// source: service/channelz/channelz.proto

package grpc_channelz

import (
	context "context"
	fmt "fmt"
	gira "github.com/lujingwei002/gira"
	errors "github.com/lujingwei002/gira/errors"
	facade "github.com/lujingwei002/gira/facade"
	service_options "github.com/lujingwei002/gira/options/service_options"
	grpc "google.golang.org/grpc"
	grpc_channelz_v1 "google.golang.org/grpc/channelz/grpc_channelz_v1"
	metadata "google.golang.org/grpc/metadata"
	sync "sync"
	time "time"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

type GetTopChannelsResponse_MulticastResult struct {
	errors       []error
	peerCount    int
	successPeers []*gira.Peer
	errorPeers   []*gira.Peer
	responses    []*grpc_channelz_v1.GetTopChannelsResponse
}

func (r *GetTopChannelsResponse_MulticastResult) Error() error {
	if len(r.errors) <= 0 {
		return nil
	}
	return r.errors[0]
}
func (r *GetTopChannelsResponse_MulticastResult) Response(index int) *grpc_channelz_v1.GetTopChannelsResponse {
	if index < 0 || index >= len(r.responses) {
		return nil
	}
	return r.responses[index]
}
func (r *GetTopChannelsResponse_MulticastResult) SuccessPeer(index int) *gira.Peer {
	if index < 0 || index >= len(r.successPeers) {
		return nil
	}
	return r.successPeers[index]
}
func (r *GetTopChannelsResponse_MulticastResult) ErrorPeer(index int) *gira.Peer {
	if index < 0 || index >= len(r.errorPeers) {
		return nil
	}
	return r.errorPeers[index]
}
func (r *GetTopChannelsResponse_MulticastResult) PeerCount() int {
	return r.peerCount
}
func (r *GetTopChannelsResponse_MulticastResult) SuccessCount() int {
	return len(r.successPeers)
}
func (r *GetTopChannelsResponse_MulticastResult) ErrorCount() int {
	return len(r.errorPeers)
}
func (r *GetTopChannelsResponse_MulticastResult) Errors(index int) error {
	if index < 0 || index >= len(r.errors) {
		return nil
	}
	return r.errors[index]
}

type GetServersResponse_MulticastResult struct {
	errors       []error
	peerCount    int
	successPeers []*gira.Peer
	errorPeers   []*gira.Peer
	responses    []*grpc_channelz_v1.GetServersResponse
}

func (r *GetServersResponse_MulticastResult) Error() error {
	if len(r.errors) <= 0 {
		return nil
	}
	return r.errors[0]
}
func (r *GetServersResponse_MulticastResult) Response(index int) *grpc_channelz_v1.GetServersResponse {
	if index < 0 || index >= len(r.responses) {
		return nil
	}
	return r.responses[index]
}
func (r *GetServersResponse_MulticastResult) SuccessPeer(index int) *gira.Peer {
	if index < 0 || index >= len(r.successPeers) {
		return nil
	}
	return r.successPeers[index]
}
func (r *GetServersResponse_MulticastResult) ErrorPeer(index int) *gira.Peer {
	if index < 0 || index >= len(r.errorPeers) {
		return nil
	}
	return r.errorPeers[index]
}
func (r *GetServersResponse_MulticastResult) PeerCount() int {
	return r.peerCount
}
func (r *GetServersResponse_MulticastResult) SuccessCount() int {
	return len(r.successPeers)
}
func (r *GetServersResponse_MulticastResult) ErrorCount() int {
	return len(r.errorPeers)
}
func (r *GetServersResponse_MulticastResult) Errors(index int) error {
	if index < 0 || index >= len(r.errors) {
		return nil
	}
	return r.errors[index]
}

type GetServerResponse_MulticastResult struct {
	errors       []error
	peerCount    int
	successPeers []*gira.Peer
	errorPeers   []*gira.Peer
	responses    []*grpc_channelz_v1.GetServerResponse
}

func (r *GetServerResponse_MulticastResult) Error() error {
	if len(r.errors) <= 0 {
		return nil
	}
	return r.errors[0]
}
func (r *GetServerResponse_MulticastResult) Response(index int) *grpc_channelz_v1.GetServerResponse {
	if index < 0 || index >= len(r.responses) {
		return nil
	}
	return r.responses[index]
}
func (r *GetServerResponse_MulticastResult) SuccessPeer(index int) *gira.Peer {
	if index < 0 || index >= len(r.successPeers) {
		return nil
	}
	return r.successPeers[index]
}
func (r *GetServerResponse_MulticastResult) ErrorPeer(index int) *gira.Peer {
	if index < 0 || index >= len(r.errorPeers) {
		return nil
	}
	return r.errorPeers[index]
}
func (r *GetServerResponse_MulticastResult) PeerCount() int {
	return r.peerCount
}
func (r *GetServerResponse_MulticastResult) SuccessCount() int {
	return len(r.successPeers)
}
func (r *GetServerResponse_MulticastResult) ErrorCount() int {
	return len(r.errorPeers)
}
func (r *GetServerResponse_MulticastResult) Errors(index int) error {
	if index < 0 || index >= len(r.errors) {
		return nil
	}
	return r.errors[index]
}

type GetServerSocketsResponse_MulticastResult struct {
	errors       []error
	peerCount    int
	successPeers []*gira.Peer
	errorPeers   []*gira.Peer
	responses    []*grpc_channelz_v1.GetServerSocketsResponse
}

func (r *GetServerSocketsResponse_MulticastResult) Error() error {
	if len(r.errors) <= 0 {
		return nil
	}
	return r.errors[0]
}
func (r *GetServerSocketsResponse_MulticastResult) Response(index int) *grpc_channelz_v1.GetServerSocketsResponse {
	if index < 0 || index >= len(r.responses) {
		return nil
	}
	return r.responses[index]
}
func (r *GetServerSocketsResponse_MulticastResult) SuccessPeer(index int) *gira.Peer {
	if index < 0 || index >= len(r.successPeers) {
		return nil
	}
	return r.successPeers[index]
}
func (r *GetServerSocketsResponse_MulticastResult) ErrorPeer(index int) *gira.Peer {
	if index < 0 || index >= len(r.errorPeers) {
		return nil
	}
	return r.errorPeers[index]
}
func (r *GetServerSocketsResponse_MulticastResult) PeerCount() int {
	return r.peerCount
}
func (r *GetServerSocketsResponse_MulticastResult) SuccessCount() int {
	return len(r.successPeers)
}
func (r *GetServerSocketsResponse_MulticastResult) ErrorCount() int {
	return len(r.errorPeers)
}
func (r *GetServerSocketsResponse_MulticastResult) Errors(index int) error {
	if index < 0 || index >= len(r.errors) {
		return nil
	}
	return r.errors[index]
}

type GetChannelResponse_MulticastResult struct {
	errors       []error
	peerCount    int
	successPeers []*gira.Peer
	errorPeers   []*gira.Peer
	responses    []*grpc_channelz_v1.GetChannelResponse
}

func (r *GetChannelResponse_MulticastResult) Error() error {
	if len(r.errors) <= 0 {
		return nil
	}
	return r.errors[0]
}
func (r *GetChannelResponse_MulticastResult) Response(index int) *grpc_channelz_v1.GetChannelResponse {
	if index < 0 || index >= len(r.responses) {
		return nil
	}
	return r.responses[index]
}
func (r *GetChannelResponse_MulticastResult) SuccessPeer(index int) *gira.Peer {
	if index < 0 || index >= len(r.successPeers) {
		return nil
	}
	return r.successPeers[index]
}
func (r *GetChannelResponse_MulticastResult) ErrorPeer(index int) *gira.Peer {
	if index < 0 || index >= len(r.errorPeers) {
		return nil
	}
	return r.errorPeers[index]
}
func (r *GetChannelResponse_MulticastResult) PeerCount() int {
	return r.peerCount
}
func (r *GetChannelResponse_MulticastResult) SuccessCount() int {
	return len(r.successPeers)
}
func (r *GetChannelResponse_MulticastResult) ErrorCount() int {
	return len(r.errorPeers)
}
func (r *GetChannelResponse_MulticastResult) Errors(index int) error {
	if index < 0 || index >= len(r.errors) {
		return nil
	}
	return r.errors[index]
}

type GetSubchannelResponse_MulticastResult struct {
	errors       []error
	peerCount    int
	successPeers []*gira.Peer
	errorPeers   []*gira.Peer
	responses    []*grpc_channelz_v1.GetSubchannelResponse
}

func (r *GetSubchannelResponse_MulticastResult) Error() error {
	if len(r.errors) <= 0 {
		return nil
	}
	return r.errors[0]
}
func (r *GetSubchannelResponse_MulticastResult) Response(index int) *grpc_channelz_v1.GetSubchannelResponse {
	if index < 0 || index >= len(r.responses) {
		return nil
	}
	return r.responses[index]
}
func (r *GetSubchannelResponse_MulticastResult) SuccessPeer(index int) *gira.Peer {
	if index < 0 || index >= len(r.successPeers) {
		return nil
	}
	return r.successPeers[index]
}
func (r *GetSubchannelResponse_MulticastResult) ErrorPeer(index int) *gira.Peer {
	if index < 0 || index >= len(r.errorPeers) {
		return nil
	}
	return r.errorPeers[index]
}
func (r *GetSubchannelResponse_MulticastResult) PeerCount() int {
	return r.peerCount
}
func (r *GetSubchannelResponse_MulticastResult) SuccessCount() int {
	return len(r.successPeers)
}
func (r *GetSubchannelResponse_MulticastResult) ErrorCount() int {
	return len(r.errorPeers)
}
func (r *GetSubchannelResponse_MulticastResult) Errors(index int) error {
	if index < 0 || index >= len(r.errors) {
		return nil
	}
	return r.errors[index]
}

type GetSocketResponse_MulticastResult struct {
	errors       []error
	peerCount    int
	successPeers []*gira.Peer
	errorPeers   []*gira.Peer
	responses    []*grpc_channelz_v1.GetSocketResponse
}

func (r *GetSocketResponse_MulticastResult) Error() error {
	if len(r.errors) <= 0 {
		return nil
	}
	return r.errors[0]
}
func (r *GetSocketResponse_MulticastResult) Response(index int) *grpc_channelz_v1.GetSocketResponse {
	if index < 0 || index >= len(r.responses) {
		return nil
	}
	return r.responses[index]
}
func (r *GetSocketResponse_MulticastResult) SuccessPeer(index int) *gira.Peer {
	if index < 0 || index >= len(r.successPeers) {
		return nil
	}
	return r.successPeers[index]
}
func (r *GetSocketResponse_MulticastResult) ErrorPeer(index int) *gira.Peer {
	if index < 0 || index >= len(r.errorPeers) {
		return nil
	}
	return r.errorPeers[index]
}
func (r *GetSocketResponse_MulticastResult) PeerCount() int {
	return r.peerCount
}
func (r *GetSocketResponse_MulticastResult) SuccessCount() int {
	return len(r.successPeers)
}
func (r *GetSocketResponse_MulticastResult) ErrorCount() int {
	return len(r.errorPeers)
}
func (r *GetSocketResponse_MulticastResult) Errors(index int) error {
	if index < 0 || index >= len(r.errors) {
		return nil
	}
	return r.errors[index]
}

const (
	ChannelzServerName = "grpc.channelz.v1.Channelz"
)

// ChannelzClient is the client API for Channelz service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ChannelzClients interface {
	WithServiceName(serviceName string) ChannelzClients
	Local() ChannelzClientsLocal
	Unicast() ChannelzClientsUnicast
	Multicast(count int) ChannelzClientsMulticast
	Broadcast() ChannelzClientsMulticast

	// Gets all root channels (i.e. channels the application has directly
	// created). This does not include subchannels nor non-top level channels.
	GetTopChannels(ctx context.Context, address string, in *grpc_channelz_v1.GetTopChannelsRequest, opts ...grpc.CallOption) (*grpc_channelz_v1.GetTopChannelsResponse, error)
	// Gets all servers that exist in the process.
	GetServers(ctx context.Context, address string, in *grpc_channelz_v1.GetServersRequest, opts ...grpc.CallOption) (*grpc_channelz_v1.GetServersResponse, error)
	// Returns a single Server, or else a NOT_FOUND code.
	GetServer(ctx context.Context, address string, in *grpc_channelz_v1.GetServerRequest, opts ...grpc.CallOption) (*grpc_channelz_v1.GetServerResponse, error)
	// Gets all server sockets that exist in the process.
	GetServerSockets(ctx context.Context, address string, in *grpc_channelz_v1.GetServerSocketsRequest, opts ...grpc.CallOption) (*grpc_channelz_v1.GetServerSocketsResponse, error)
	// Returns a single Channel, or else a NOT_FOUND code.
	GetChannel(ctx context.Context, address string, in *grpc_channelz_v1.GetChannelRequest, opts ...grpc.CallOption) (*grpc_channelz_v1.GetChannelResponse, error)
	// Returns a single Subchannel, or else a NOT_FOUND code.
	GetSubchannel(ctx context.Context, address string, in *grpc_channelz_v1.GetSubchannelRequest, opts ...grpc.CallOption) (*grpc_channelz_v1.GetSubchannelResponse, error)
	// Returns a single Socket or else a NOT_FOUND code.
	GetSocket(ctx context.Context, address string, in *grpc_channelz_v1.GetSocketRequest, opts ...grpc.CallOption) (*grpc_channelz_v1.GetSocketResponse, error)
}

type ChannelzClientsMulticast interface {
	WhereRegex(regex string) ChannelzClientsMulticast
	WherePrefix(prefix bool) ChannelzClientsMulticast
	// Gets all root channels (i.e. channels the application has directly
	// created). This does not include subchannels nor non-top level channels.
	GetTopChannels(ctx context.Context, in *grpc_channelz_v1.GetTopChannelsRequest, opts ...grpc.CallOption) (*GetTopChannelsResponse_MulticastResult, error)
	// Gets all servers that exist in the process.
	GetServers(ctx context.Context, in *grpc_channelz_v1.GetServersRequest, opts ...grpc.CallOption) (*GetServersResponse_MulticastResult, error)
	// Returns a single Server, or else a NOT_FOUND code.
	GetServer(ctx context.Context, in *grpc_channelz_v1.GetServerRequest, opts ...grpc.CallOption) (*GetServerResponse_MulticastResult, error)
	// Gets all server sockets that exist in the process.
	GetServerSockets(ctx context.Context, in *grpc_channelz_v1.GetServerSocketsRequest, opts ...grpc.CallOption) (*GetServerSocketsResponse_MulticastResult, error)
	// Returns a single Channel, or else a NOT_FOUND code.
	GetChannel(ctx context.Context, in *grpc_channelz_v1.GetChannelRequest, opts ...grpc.CallOption) (*GetChannelResponse_MulticastResult, error)
	// Returns a single Subchannel, or else a NOT_FOUND code.
	GetSubchannel(ctx context.Context, in *grpc_channelz_v1.GetSubchannelRequest, opts ...grpc.CallOption) (*GetSubchannelResponse_MulticastResult, error)
	// Returns a single Socket or else a NOT_FOUND code.
	GetSocket(ctx context.Context, in *grpc_channelz_v1.GetSocketRequest, opts ...grpc.CallOption) (*GetSocketResponse_MulticastResult, error)
}

type ChannelzClientsUnicast interface {
	Where(serviceName string) ChannelzClientsUnicast
	WherePeer(peer *gira.Peer) ChannelzClientsUnicast
	WhereAddress(address string) ChannelzClientsUnicast
	WhereUser(userId string) ChannelzClientsUnicast

	// Gets all root channels (i.e. channels the application has directly
	// created). This does not include subchannels nor non-top level channels.
	GetTopChannels(ctx context.Context, in *grpc_channelz_v1.GetTopChannelsRequest, opts ...grpc.CallOption) (*grpc_channelz_v1.GetTopChannelsResponse, error)
	// Gets all servers that exist in the process.
	GetServers(ctx context.Context, in *grpc_channelz_v1.GetServersRequest, opts ...grpc.CallOption) (*grpc_channelz_v1.GetServersResponse, error)
	// Returns a single Server, or else a NOT_FOUND code.
	GetServer(ctx context.Context, in *grpc_channelz_v1.GetServerRequest, opts ...grpc.CallOption) (*grpc_channelz_v1.GetServerResponse, error)
	// Gets all server sockets that exist in the process.
	GetServerSockets(ctx context.Context, in *grpc_channelz_v1.GetServerSocketsRequest, opts ...grpc.CallOption) (*grpc_channelz_v1.GetServerSocketsResponse, error)
	// Returns a single Channel, or else a NOT_FOUND code.
	GetChannel(ctx context.Context, in *grpc_channelz_v1.GetChannelRequest, opts ...grpc.CallOption) (*grpc_channelz_v1.GetChannelResponse, error)
	// Returns a single Subchannel, or else a NOT_FOUND code.
	GetSubchannel(ctx context.Context, in *grpc_channelz_v1.GetSubchannelRequest, opts ...grpc.CallOption) (*grpc_channelz_v1.GetSubchannelResponse, error)
	// Returns a single Socket or else a NOT_FOUND code.
	GetSocket(ctx context.Context, in *grpc_channelz_v1.GetSocketRequest, opts ...grpc.CallOption) (*grpc_channelz_v1.GetSocketResponse, error)
}

type ChannelzClientsLocal interface {
	WhereUser(userId string) ChannelzClientsLocal
	WithTimeout(timeout int64) ChannelzClientsLocal

	// Gets all root channels (i.e. channels the application has directly
	// created). This does not include subchannels nor non-top level channels.
	GetTopChannels(ctx context.Context, in *grpc_channelz_v1.GetTopChannelsRequest, opts ...grpc.CallOption) (*grpc_channelz_v1.GetTopChannelsResponse, error)
	// Gets all servers that exist in the process.
	GetServers(ctx context.Context, in *grpc_channelz_v1.GetServersRequest, opts ...grpc.CallOption) (*grpc_channelz_v1.GetServersResponse, error)
	// Returns a single Server, or else a NOT_FOUND code.
	GetServer(ctx context.Context, in *grpc_channelz_v1.GetServerRequest, opts ...grpc.CallOption) (*grpc_channelz_v1.GetServerResponse, error)
	// Gets all server sockets that exist in the process.
	GetServerSockets(ctx context.Context, in *grpc_channelz_v1.GetServerSocketsRequest, opts ...grpc.CallOption) (*grpc_channelz_v1.GetServerSocketsResponse, error)
	// Returns a single Channel, or else a NOT_FOUND code.
	GetChannel(ctx context.Context, in *grpc_channelz_v1.GetChannelRequest, opts ...grpc.CallOption) (*grpc_channelz_v1.GetChannelResponse, error)
	// Returns a single Subchannel, or else a NOT_FOUND code.
	GetSubchannel(ctx context.Context, in *grpc_channelz_v1.GetSubchannelRequest, opts ...grpc.CallOption) (*grpc_channelz_v1.GetSubchannelResponse, error)
	// Returns a single Socket or else a NOT_FOUND code.
	GetSocket(ctx context.Context, in *grpc_channelz_v1.GetSocketRequest, opts ...grpc.CallOption) (*grpc_channelz_v1.GetSocketResponse, error)
}

type channelzClients struct {
	mu          sync.Mutex
	clientPool  map[string]*sync.Pool
	serviceName string
}

func NewChannelzClients() ChannelzClients {
	return &channelzClients{
		serviceName: ChannelzServerName,
		clientPool:  make(map[string]*sync.Pool, 0),
	}
}

var DefaultChannelzClients = NewChannelzClients()

func (c *channelzClients) getClient(address string) (grpc_channelz_v1.ChannelzClient, error) {
	c.mu.Lock()
	var pool *sync.Pool
	var ok bool
	if pool, ok = c.clientPool[address]; !ok {
		pool = &sync.Pool{
			New: func() any {
				conn, err := grpc.Dial(address, grpc.WithInsecure())
				if err != nil {
					return err
				}
				client := grpc_channelz_v1.NewChannelzClient(conn)
				return client
			},
		}
		c.clientPool[address] = pool
		c.mu.Unlock()
	} else {
		c.mu.Unlock()
	}
	if v := pool.Get(); v == nil {
		return nil, errors.ErrGrpcClientPoolNil
	} else if err, ok := v.(error); ok {
		return nil, err
	} else {
		return v.(grpc_channelz_v1.ChannelzClient), nil
	}
}

func (c *channelzClients) putClient(address string, client grpc_channelz_v1.ChannelzClient) {
	c.mu.Lock()
	var pool *sync.Pool
	var ok bool
	if pool, ok = c.clientPool[address]; ok {
		pool.Put(client)
	}
	c.mu.Unlock()
}

func (c *channelzClients) WithServiceName(serviceName string) ChannelzClients {
	c.serviceName = serviceName
	return c
}

func (c *channelzClients) Local() ChannelzClientsLocal {
	headers := make(map[string]string)
	u := &channelzClientsLocal{
		timeout: 5,
		headers: metadata.New(headers),
		client:  c,
	}
	return u
}

func (c *channelzClients) Unicast() ChannelzClientsUnicast {
	headers := make(map[string]string)
	u := &channelzClientsUnicast{
		headers: metadata.New(headers),
		client:  c,
	}
	return u
}

func (c *channelzClients) Multicast(count int) ChannelzClientsMulticast {
	u := &channelzClientsMulticast{
		count:       count,
		serviceName: fmt.Sprintf("%s/", c.serviceName),
		client:      c,
	}
	return u
}

func (c *channelzClients) Broadcast() ChannelzClientsMulticast {
	u := &channelzClientsMulticast{
		count:       -1,
		serviceName: fmt.Sprintf("%s/", c.serviceName),
		client:      c,
	}
	return u
}

func (c *channelzClients) GetTopChannels(ctx context.Context, address string, in *grpc_channelz_v1.GetTopChannelsRequest, opts ...grpc.CallOption) (*grpc_channelz_v1.GetTopChannelsResponse, error) {
	client, err := c.getClient(address)
	if err != nil {
		return nil, err
	}
	defer c.putClient(address, client)
	out, err := client.GetTopChannels(ctx, in, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *channelzClients) GetServers(ctx context.Context, address string, in *grpc_channelz_v1.GetServersRequest, opts ...grpc.CallOption) (*grpc_channelz_v1.GetServersResponse, error) {
	client, err := c.getClient(address)
	if err != nil {
		return nil, err
	}
	defer c.putClient(address, client)
	out, err := client.GetServers(ctx, in, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *channelzClients) GetServer(ctx context.Context, address string, in *grpc_channelz_v1.GetServerRequest, opts ...grpc.CallOption) (*grpc_channelz_v1.GetServerResponse, error) {
	client, err := c.getClient(address)
	if err != nil {
		return nil, err
	}
	defer c.putClient(address, client)
	out, err := client.GetServer(ctx, in, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *channelzClients) GetServerSockets(ctx context.Context, address string, in *grpc_channelz_v1.GetServerSocketsRequest, opts ...grpc.CallOption) (*grpc_channelz_v1.GetServerSocketsResponse, error) {
	client, err := c.getClient(address)
	if err != nil {
		return nil, err
	}
	defer c.putClient(address, client)
	out, err := client.GetServerSockets(ctx, in, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *channelzClients) GetChannel(ctx context.Context, address string, in *grpc_channelz_v1.GetChannelRequest, opts ...grpc.CallOption) (*grpc_channelz_v1.GetChannelResponse, error) {
	client, err := c.getClient(address)
	if err != nil {
		return nil, err
	}
	defer c.putClient(address, client)
	out, err := client.GetChannel(ctx, in, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *channelzClients) GetSubchannel(ctx context.Context, address string, in *grpc_channelz_v1.GetSubchannelRequest, opts ...grpc.CallOption) (*grpc_channelz_v1.GetSubchannelResponse, error) {
	client, err := c.getClient(address)
	if err != nil {
		return nil, err
	}
	defer c.putClient(address, client)
	out, err := client.GetSubchannel(ctx, in, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *channelzClients) GetSocket(ctx context.Context, address string, in *grpc_channelz_v1.GetSocketRequest, opts ...grpc.CallOption) (*grpc_channelz_v1.GetSocketResponse, error) {
	client, err := c.getClient(address)
	if err != nil {
		return nil, err
	}
	defer c.putClient(address, client)
	out, err := client.GetSocket(ctx, in, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

type channelzClientsLocal struct {
	timeout int64
	userId  string
	client  *channelzClients
	headers metadata.MD
}

func (c *channelzClientsLocal) WhereUser(userId string) ChannelzClientsLocal {
	c.userId = userId
	c.headers.Append(gira.GRPC_PATH_KEY, userId)
	return c
}

func (c *channelzClientsLocal) WithTimeout(timeout int64) ChannelzClientsLocal {
	c.timeout = timeout
	return c
}

func (c *channelzClientsLocal) GetTopChannels(ctx context.Context, in *grpc_channelz_v1.GetTopChannelsRequest, opts ...grpc.CallOption) (*grpc_channelz_v1.GetTopChannelsResponse, error) {
	cancelCtx, cancelFunc := context.WithTimeout(ctx, time.Second*time.Duration(c.timeout))
	defer cancelFunc()
	if c.headers.Len() > 0 {
		cancelCtx = metadata.NewOutgoingContext(cancelCtx, c.headers)
	}
	if s, ok := facade.WhereIsServer(c.client.serviceName); !ok {
		return nil, errors.ErrServerNotFound
	} else if svr, ok := s.(grpc_channelz_v1.ChannelzServer); !ok {
		return nil, errors.ErrServerNotFound
	} else {
		return svr.GetTopChannels(cancelCtx, in)
	}
}

func (c *channelzClientsLocal) GetServers(ctx context.Context, in *grpc_channelz_v1.GetServersRequest, opts ...grpc.CallOption) (*grpc_channelz_v1.GetServersResponse, error) {
	cancelCtx, cancelFunc := context.WithTimeout(ctx, time.Second*time.Duration(c.timeout))
	defer cancelFunc()
	if c.headers.Len() > 0 {
		cancelCtx = metadata.NewOutgoingContext(cancelCtx, c.headers)
	}
	if s, ok := facade.WhereIsServer(c.client.serviceName); !ok {
		return nil, errors.ErrServerNotFound
	} else if svr, ok := s.(grpc_channelz_v1.ChannelzServer); !ok {
		return nil, errors.ErrServerNotFound
	} else {
		return svr.GetServers(cancelCtx, in)
	}
}

func (c *channelzClientsLocal) GetServer(ctx context.Context, in *grpc_channelz_v1.GetServerRequest, opts ...grpc.CallOption) (*grpc_channelz_v1.GetServerResponse, error) {
	cancelCtx, cancelFunc := context.WithTimeout(ctx, time.Second*time.Duration(c.timeout))
	defer cancelFunc()
	if c.headers.Len() > 0 {
		cancelCtx = metadata.NewOutgoingContext(cancelCtx, c.headers)
	}
	if s, ok := facade.WhereIsServer(c.client.serviceName); !ok {
		return nil, errors.ErrServerNotFound
	} else if svr, ok := s.(grpc_channelz_v1.ChannelzServer); !ok {
		return nil, errors.ErrServerNotFound
	} else {
		return svr.GetServer(cancelCtx, in)
	}
}

func (c *channelzClientsLocal) GetServerSockets(ctx context.Context, in *grpc_channelz_v1.GetServerSocketsRequest, opts ...grpc.CallOption) (*grpc_channelz_v1.GetServerSocketsResponse, error) {
	cancelCtx, cancelFunc := context.WithTimeout(ctx, time.Second*time.Duration(c.timeout))
	defer cancelFunc()
	if c.headers.Len() > 0 {
		cancelCtx = metadata.NewOutgoingContext(cancelCtx, c.headers)
	}
	if s, ok := facade.WhereIsServer(c.client.serviceName); !ok {
		return nil, errors.ErrServerNotFound
	} else if svr, ok := s.(grpc_channelz_v1.ChannelzServer); !ok {
		return nil, errors.ErrServerNotFound
	} else {
		return svr.GetServerSockets(cancelCtx, in)
	}
}

func (c *channelzClientsLocal) GetChannel(ctx context.Context, in *grpc_channelz_v1.GetChannelRequest, opts ...grpc.CallOption) (*grpc_channelz_v1.GetChannelResponse, error) {
	cancelCtx, cancelFunc := context.WithTimeout(ctx, time.Second*time.Duration(c.timeout))
	defer cancelFunc()
	if c.headers.Len() > 0 {
		cancelCtx = metadata.NewOutgoingContext(cancelCtx, c.headers)
	}
	if s, ok := facade.WhereIsServer(c.client.serviceName); !ok {
		return nil, errors.ErrServerNotFound
	} else if svr, ok := s.(grpc_channelz_v1.ChannelzServer); !ok {
		return nil, errors.ErrServerNotFound
	} else {
		return svr.GetChannel(cancelCtx, in)
	}
}

func (c *channelzClientsLocal) GetSubchannel(ctx context.Context, in *grpc_channelz_v1.GetSubchannelRequest, opts ...grpc.CallOption) (*grpc_channelz_v1.GetSubchannelResponse, error) {
	cancelCtx, cancelFunc := context.WithTimeout(ctx, time.Second*time.Duration(c.timeout))
	defer cancelFunc()
	if c.headers.Len() > 0 {
		cancelCtx = metadata.NewOutgoingContext(cancelCtx, c.headers)
	}
	if s, ok := facade.WhereIsServer(c.client.serviceName); !ok {
		return nil, errors.ErrServerNotFound
	} else if svr, ok := s.(grpc_channelz_v1.ChannelzServer); !ok {
		return nil, errors.ErrServerNotFound
	} else {
		return svr.GetSubchannel(cancelCtx, in)
	}
}

func (c *channelzClientsLocal) GetSocket(ctx context.Context, in *grpc_channelz_v1.GetSocketRequest, opts ...grpc.CallOption) (*grpc_channelz_v1.GetSocketResponse, error) {
	cancelCtx, cancelFunc := context.WithTimeout(ctx, time.Second*time.Duration(c.timeout))
	defer cancelFunc()
	if c.headers.Len() > 0 {
		cancelCtx = metadata.NewOutgoingContext(cancelCtx, c.headers)
	}
	if s, ok := facade.WhereIsServer(c.client.serviceName); !ok {
		return nil, errors.ErrServerNotFound
	} else if svr, ok := s.(grpc_channelz_v1.ChannelzServer); !ok {
		return nil, errors.ErrServerNotFound
	} else {
		return svr.GetSocket(cancelCtx, in)
	}
}

type channelzClientsUnicast struct {
	peer        *gira.Peer
	serviceName string
	address     string
	userId      string
	client      *channelzClients
	headers     metadata.MD
}

func (c *channelzClientsUnicast) Where(serviceName string) ChannelzClientsUnicast {
	c.serviceName = serviceName
	return c
}

func (c *channelzClientsUnicast) WherePeer(peer *gira.Peer) ChannelzClientsUnicast {
	c.peer = peer
	return c
}

func (c *channelzClientsUnicast) WhereAddress(address string) ChannelzClientsUnicast {
	c.address = address
	return c
}

func (c *channelzClientsUnicast) WhereUser(userId string) ChannelzClientsUnicast {
	c.userId = userId
	c.headers.Append(gira.GRPC_PATH_KEY, userId)
	return c
}

func (c *channelzClientsUnicast) GetTopChannels(ctx context.Context, in *grpc_channelz_v1.GetTopChannelsRequest, opts ...grpc.CallOption) (*grpc_channelz_v1.GetTopChannelsResponse, error) {
	var address string
	if len(c.address) > 0 {
		address = c.address
	} else if c.peer != nil && facade.IsEnableResolver() {
		address = c.peer.Url
	} else if c.peer != nil {
		address = c.peer.Address
	} else if len(c.serviceName) > 0 {
		if peers, err := facade.WhereIsServiceName(c.serviceName); err != nil {
			return nil, err
		} else if len(peers) < 1 {
			return nil, errors.ErrPeerNotFound
		} else if facade.IsEnableResolver() {
			address = peers[0].Url
		} else {
			address = peers[0].Address
		}
	} else if len(c.userId) > 0 {
		if peer, err := facade.WhereIsUser(c.userId); err != nil {
			return nil, err
		} else if facade.IsEnableResolver() {
			address = peer.Url
		} else {
			address = peer.Address
		}
	}
	if len(address) <= 0 {
		return nil, errors.ErrPeerNotFound
	}
	client, err := c.client.getClient(address)
	if err != nil {
		return nil, err
	}
	defer c.client.putClient(address, client)
	if c.headers.Len() > 0 {
		ctx = metadata.NewOutgoingContext(ctx, c.headers)
	}
	out, err := client.GetTopChannels(ctx, in, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *channelzClientsUnicast) GetServers(ctx context.Context, in *grpc_channelz_v1.GetServersRequest, opts ...grpc.CallOption) (*grpc_channelz_v1.GetServersResponse, error) {
	var address string
	if len(c.address) > 0 {
		address = c.address
	} else if c.peer != nil && facade.IsEnableResolver() {
		address = c.peer.Url
	} else if c.peer != nil {
		address = c.peer.Address
	} else if len(c.serviceName) > 0 {
		if peers, err := facade.WhereIsServiceName(c.serviceName); err != nil {
			return nil, err
		} else if len(peers) < 1 {
			return nil, errors.ErrPeerNotFound
		} else if facade.IsEnableResolver() {
			address = peers[0].Url
		} else {
			address = peers[0].Address
		}
	} else if len(c.userId) > 0 {
		if peer, err := facade.WhereIsUser(c.userId); err != nil {
			return nil, err
		} else if facade.IsEnableResolver() {
			address = peer.Url
		} else {
			address = peer.Address
		}
	}
	if len(address) <= 0 {
		return nil, errors.ErrPeerNotFound
	}
	client, err := c.client.getClient(address)
	if err != nil {
		return nil, err
	}
	defer c.client.putClient(address, client)
	if c.headers.Len() > 0 {
		ctx = metadata.NewOutgoingContext(ctx, c.headers)
	}
	out, err := client.GetServers(ctx, in, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *channelzClientsUnicast) GetServer(ctx context.Context, in *grpc_channelz_v1.GetServerRequest, opts ...grpc.CallOption) (*grpc_channelz_v1.GetServerResponse, error) {
	var address string
	if len(c.address) > 0 {
		address = c.address
	} else if c.peer != nil && facade.IsEnableResolver() {
		address = c.peer.Url
	} else if c.peer != nil {
		address = c.peer.Address
	} else if len(c.serviceName) > 0 {
		if peers, err := facade.WhereIsServiceName(c.serviceName); err != nil {
			return nil, err
		} else if len(peers) < 1 {
			return nil, errors.ErrPeerNotFound
		} else if facade.IsEnableResolver() {
			address = peers[0].Url
		} else {
			address = peers[0].Address
		}
	} else if len(c.userId) > 0 {
		if peer, err := facade.WhereIsUser(c.userId); err != nil {
			return nil, err
		} else if facade.IsEnableResolver() {
			address = peer.Url
		} else {
			address = peer.Address
		}
	}
	if len(address) <= 0 {
		return nil, errors.ErrPeerNotFound
	}
	client, err := c.client.getClient(address)
	if err != nil {
		return nil, err
	}
	defer c.client.putClient(address, client)
	if c.headers.Len() > 0 {
		ctx = metadata.NewOutgoingContext(ctx, c.headers)
	}
	out, err := client.GetServer(ctx, in, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *channelzClientsUnicast) GetServerSockets(ctx context.Context, in *grpc_channelz_v1.GetServerSocketsRequest, opts ...grpc.CallOption) (*grpc_channelz_v1.GetServerSocketsResponse, error) {
	var address string
	if len(c.address) > 0 {
		address = c.address
	} else if c.peer != nil && facade.IsEnableResolver() {
		address = c.peer.Url
	} else if c.peer != nil {
		address = c.peer.Address
	} else if len(c.serviceName) > 0 {
		if peers, err := facade.WhereIsServiceName(c.serviceName); err != nil {
			return nil, err
		} else if len(peers) < 1 {
			return nil, errors.ErrPeerNotFound
		} else if facade.IsEnableResolver() {
			address = peers[0].Url
		} else {
			address = peers[0].Address
		}
	} else if len(c.userId) > 0 {
		if peer, err := facade.WhereIsUser(c.userId); err != nil {
			return nil, err
		} else if facade.IsEnableResolver() {
			address = peer.Url
		} else {
			address = peer.Address
		}
	}
	if len(address) <= 0 {
		return nil, errors.ErrPeerNotFound
	}
	client, err := c.client.getClient(address)
	if err != nil {
		return nil, err
	}
	defer c.client.putClient(address, client)
	if c.headers.Len() > 0 {
		ctx = metadata.NewOutgoingContext(ctx, c.headers)
	}
	out, err := client.GetServerSockets(ctx, in, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *channelzClientsUnicast) GetChannel(ctx context.Context, in *grpc_channelz_v1.GetChannelRequest, opts ...grpc.CallOption) (*grpc_channelz_v1.GetChannelResponse, error) {
	var address string
	if len(c.address) > 0 {
		address = c.address
	} else if c.peer != nil && facade.IsEnableResolver() {
		address = c.peer.Url
	} else if c.peer != nil {
		address = c.peer.Address
	} else if len(c.serviceName) > 0 {
		if peers, err := facade.WhereIsServiceName(c.serviceName); err != nil {
			return nil, err
		} else if len(peers) < 1 {
			return nil, errors.ErrPeerNotFound
		} else if facade.IsEnableResolver() {
			address = peers[0].Url
		} else {
			address = peers[0].Address
		}
	} else if len(c.userId) > 0 {
		if peer, err := facade.WhereIsUser(c.userId); err != nil {
			return nil, err
		} else if facade.IsEnableResolver() {
			address = peer.Url
		} else {
			address = peer.Address
		}
	}
	if len(address) <= 0 {
		return nil, errors.ErrPeerNotFound
	}
	client, err := c.client.getClient(address)
	if err != nil {
		return nil, err
	}
	defer c.client.putClient(address, client)
	if c.headers.Len() > 0 {
		ctx = metadata.NewOutgoingContext(ctx, c.headers)
	}
	out, err := client.GetChannel(ctx, in, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *channelzClientsUnicast) GetSubchannel(ctx context.Context, in *grpc_channelz_v1.GetSubchannelRequest, opts ...grpc.CallOption) (*grpc_channelz_v1.GetSubchannelResponse, error) {
	var address string
	if len(c.address) > 0 {
		address = c.address
	} else if c.peer != nil && facade.IsEnableResolver() {
		address = c.peer.Url
	} else if c.peer != nil {
		address = c.peer.Address
	} else if len(c.serviceName) > 0 {
		if peers, err := facade.WhereIsServiceName(c.serviceName); err != nil {
			return nil, err
		} else if len(peers) < 1 {
			return nil, errors.ErrPeerNotFound
		} else if facade.IsEnableResolver() {
			address = peers[0].Url
		} else {
			address = peers[0].Address
		}
	} else if len(c.userId) > 0 {
		if peer, err := facade.WhereIsUser(c.userId); err != nil {
			return nil, err
		} else if facade.IsEnableResolver() {
			address = peer.Url
		} else {
			address = peer.Address
		}
	}
	if len(address) <= 0 {
		return nil, errors.ErrPeerNotFound
	}
	client, err := c.client.getClient(address)
	if err != nil {
		return nil, err
	}
	defer c.client.putClient(address, client)
	if c.headers.Len() > 0 {
		ctx = metadata.NewOutgoingContext(ctx, c.headers)
	}
	out, err := client.GetSubchannel(ctx, in, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *channelzClientsUnicast) GetSocket(ctx context.Context, in *grpc_channelz_v1.GetSocketRequest, opts ...grpc.CallOption) (*grpc_channelz_v1.GetSocketResponse, error) {
	var address string
	if len(c.address) > 0 {
		address = c.address
	} else if c.peer != nil && facade.IsEnableResolver() {
		address = c.peer.Url
	} else if c.peer != nil {
		address = c.peer.Address
	} else if len(c.serviceName) > 0 {
		if peers, err := facade.WhereIsServiceName(c.serviceName); err != nil {
			return nil, err
		} else if len(peers) < 1 {
			return nil, errors.ErrPeerNotFound
		} else if facade.IsEnableResolver() {
			address = peers[0].Url
		} else {
			address = peers[0].Address
		}
	} else if len(c.userId) > 0 {
		if peer, err := facade.WhereIsUser(c.userId); err != nil {
			return nil, err
		} else if facade.IsEnableResolver() {
			address = peer.Url
		} else {
			address = peer.Address
		}
	}
	if len(address) <= 0 {
		return nil, errors.ErrPeerNotFound
	}
	client, err := c.client.getClient(address)
	if err != nil {
		return nil, err
	}
	defer c.client.putClient(address, client)
	if c.headers.Len() > 0 {
		ctx = metadata.NewOutgoingContext(ctx, c.headers)
	}
	out, err := client.GetSocket(ctx, in, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

type channelzClientsMulticast struct {
	count       int
	serviceName string
	regex       string
	prefix      bool
	client      *channelzClients
}

func (c *channelzClientsMulticast) WhereRegex(regex string) ChannelzClientsMulticast {
	c.regex = regex
	return c
}

func (c *channelzClientsMulticast) WherePrefix(prefix bool) ChannelzClientsMulticast {
	c.prefix = prefix
	return c
}

func (c *channelzClientsMulticast) GetTopChannels(ctx context.Context, in *grpc_channelz_v1.GetTopChannelsRequest, opts ...grpc.CallOption) (*GetTopChannelsResponse_MulticastResult, error) {
	var peers []*gira.Peer
	var whereOpts []service_options.WhereOption
	// 多播
	whereOpts = append(whereOpts, service_options.WithWhereCatalogOption())
	if c.count > 0 {
		whereOpts = append(whereOpts, service_options.WithWhereMaxCountOption(c.count))
	}
	serviceName := c.serviceName
	if len(c.regex) > 0 {
		serviceName = fmt.Sprintf("%s%s", c.serviceName, c.regex)
		whereOpts = append(whereOpts, service_options.WithWhereRegexOption())
	}
	if c.prefix {
		whereOpts = append(whereOpts, service_options.WithWherePrefixOption())
	}
	peers, err := facade.WhereIsServiceName(serviceName, whereOpts...)
	if err != nil {
		return nil, err
	}
	result := &GetTopChannelsResponse_MulticastResult{}
	result.peerCount = len(peers)
	for _, peer := range peers {
		var address string
		if facade.IsEnableResolver() {
			address = peer.Url
		} else {
			address = peer.Address
		}
		client, err := c.client.getClient(address)
		if err != nil {
			result.errors = append(result.errors, err)
			result.errorPeers = append(result.errorPeers, peer)
			continue
		}
		out, err := client.GetTopChannels(ctx, in, opts...)
		if err != nil {
			result.errors = append(result.errors, err)
			result.errorPeers = append(result.errorPeers, peer)
			c.client.putClient(address, client)
			continue
		}
		c.client.putClient(address, client)
		result.responses = append(result.responses, out)
		result.successPeers = append(result.successPeers, peer)
	}
	return result, nil
}

func (c *channelzClientsMulticast) GetServers(ctx context.Context, in *grpc_channelz_v1.GetServersRequest, opts ...grpc.CallOption) (*GetServersResponse_MulticastResult, error) {
	var peers []*gira.Peer
	var whereOpts []service_options.WhereOption
	// 多播
	whereOpts = append(whereOpts, service_options.WithWhereCatalogOption())
	if c.count > 0 {
		whereOpts = append(whereOpts, service_options.WithWhereMaxCountOption(c.count))
	}
	serviceName := c.serviceName
	if len(c.regex) > 0 {
		serviceName = fmt.Sprintf("%s%s", c.serviceName, c.regex)
		whereOpts = append(whereOpts, service_options.WithWhereRegexOption())
	}
	if c.prefix {
		whereOpts = append(whereOpts, service_options.WithWherePrefixOption())
	}
	peers, err := facade.WhereIsServiceName(serviceName, whereOpts...)
	if err != nil {
		return nil, err
	}
	result := &GetServersResponse_MulticastResult{}
	result.peerCount = len(peers)
	for _, peer := range peers {
		var address string
		if facade.IsEnableResolver() {
			address = peer.Url
		} else {
			address = peer.Address
		}
		client, err := c.client.getClient(address)
		if err != nil {
			result.errors = append(result.errors, err)
			result.errorPeers = append(result.errorPeers, peer)
			continue
		}
		out, err := client.GetServers(ctx, in, opts...)
		if err != nil {
			result.errors = append(result.errors, err)
			result.errorPeers = append(result.errorPeers, peer)
			c.client.putClient(address, client)
			continue
		}
		c.client.putClient(address, client)
		result.responses = append(result.responses, out)
		result.successPeers = append(result.successPeers, peer)
	}
	return result, nil
}

func (c *channelzClientsMulticast) GetServer(ctx context.Context, in *grpc_channelz_v1.GetServerRequest, opts ...grpc.CallOption) (*GetServerResponse_MulticastResult, error) {
	var peers []*gira.Peer
	var whereOpts []service_options.WhereOption
	// 多播
	whereOpts = append(whereOpts, service_options.WithWhereCatalogOption())
	if c.count > 0 {
		whereOpts = append(whereOpts, service_options.WithWhereMaxCountOption(c.count))
	}
	serviceName := c.serviceName
	if len(c.regex) > 0 {
		serviceName = fmt.Sprintf("%s%s", c.serviceName, c.regex)
		whereOpts = append(whereOpts, service_options.WithWhereRegexOption())
	}
	if c.prefix {
		whereOpts = append(whereOpts, service_options.WithWherePrefixOption())
	}
	peers, err := facade.WhereIsServiceName(serviceName, whereOpts...)
	if err != nil {
		return nil, err
	}
	result := &GetServerResponse_MulticastResult{}
	result.peerCount = len(peers)
	for _, peer := range peers {
		var address string
		if facade.IsEnableResolver() {
			address = peer.Url
		} else {
			address = peer.Address
		}
		client, err := c.client.getClient(address)
		if err != nil {
			result.errors = append(result.errors, err)
			result.errorPeers = append(result.errorPeers, peer)
			continue
		}
		out, err := client.GetServer(ctx, in, opts...)
		if err != nil {
			result.errors = append(result.errors, err)
			result.errorPeers = append(result.errorPeers, peer)
			c.client.putClient(address, client)
			continue
		}
		c.client.putClient(address, client)
		result.responses = append(result.responses, out)
		result.successPeers = append(result.successPeers, peer)
	}
	return result, nil
}

func (c *channelzClientsMulticast) GetServerSockets(ctx context.Context, in *grpc_channelz_v1.GetServerSocketsRequest, opts ...grpc.CallOption) (*GetServerSocketsResponse_MulticastResult, error) {
	var peers []*gira.Peer
	var whereOpts []service_options.WhereOption
	// 多播
	whereOpts = append(whereOpts, service_options.WithWhereCatalogOption())
	if c.count > 0 {
		whereOpts = append(whereOpts, service_options.WithWhereMaxCountOption(c.count))
	}
	serviceName := c.serviceName
	if len(c.regex) > 0 {
		serviceName = fmt.Sprintf("%s%s", c.serviceName, c.regex)
		whereOpts = append(whereOpts, service_options.WithWhereRegexOption())
	}
	if c.prefix {
		whereOpts = append(whereOpts, service_options.WithWherePrefixOption())
	}
	peers, err := facade.WhereIsServiceName(serviceName, whereOpts...)
	if err != nil {
		return nil, err
	}
	result := &GetServerSocketsResponse_MulticastResult{}
	result.peerCount = len(peers)
	for _, peer := range peers {
		var address string
		if facade.IsEnableResolver() {
			address = peer.Url
		} else {
			address = peer.Address
		}
		client, err := c.client.getClient(address)
		if err != nil {
			result.errors = append(result.errors, err)
			result.errorPeers = append(result.errorPeers, peer)
			continue
		}
		out, err := client.GetServerSockets(ctx, in, opts...)
		if err != nil {
			result.errors = append(result.errors, err)
			result.errorPeers = append(result.errorPeers, peer)
			c.client.putClient(address, client)
			continue
		}
		c.client.putClient(address, client)
		result.responses = append(result.responses, out)
		result.successPeers = append(result.successPeers, peer)
	}
	return result, nil
}

func (c *channelzClientsMulticast) GetChannel(ctx context.Context, in *grpc_channelz_v1.GetChannelRequest, opts ...grpc.CallOption) (*GetChannelResponse_MulticastResult, error) {
	var peers []*gira.Peer
	var whereOpts []service_options.WhereOption
	// 多播
	whereOpts = append(whereOpts, service_options.WithWhereCatalogOption())
	if c.count > 0 {
		whereOpts = append(whereOpts, service_options.WithWhereMaxCountOption(c.count))
	}
	serviceName := c.serviceName
	if len(c.regex) > 0 {
		serviceName = fmt.Sprintf("%s%s", c.serviceName, c.regex)
		whereOpts = append(whereOpts, service_options.WithWhereRegexOption())
	}
	if c.prefix {
		whereOpts = append(whereOpts, service_options.WithWherePrefixOption())
	}
	peers, err := facade.WhereIsServiceName(serviceName, whereOpts...)
	if err != nil {
		return nil, err
	}
	result := &GetChannelResponse_MulticastResult{}
	result.peerCount = len(peers)
	for _, peer := range peers {
		var address string
		if facade.IsEnableResolver() {
			address = peer.Url
		} else {
			address = peer.Address
		}
		client, err := c.client.getClient(address)
		if err != nil {
			result.errors = append(result.errors, err)
			result.errorPeers = append(result.errorPeers, peer)
			continue
		}
		out, err := client.GetChannel(ctx, in, opts...)
		if err != nil {
			result.errors = append(result.errors, err)
			result.errorPeers = append(result.errorPeers, peer)
			c.client.putClient(address, client)
			continue
		}
		c.client.putClient(address, client)
		result.responses = append(result.responses, out)
		result.successPeers = append(result.successPeers, peer)
	}
	return result, nil
}

func (c *channelzClientsMulticast) GetSubchannel(ctx context.Context, in *grpc_channelz_v1.GetSubchannelRequest, opts ...grpc.CallOption) (*GetSubchannelResponse_MulticastResult, error) {
	var peers []*gira.Peer
	var whereOpts []service_options.WhereOption
	// 多播
	whereOpts = append(whereOpts, service_options.WithWhereCatalogOption())
	if c.count > 0 {
		whereOpts = append(whereOpts, service_options.WithWhereMaxCountOption(c.count))
	}
	serviceName := c.serviceName
	if len(c.regex) > 0 {
		serviceName = fmt.Sprintf("%s%s", c.serviceName, c.regex)
		whereOpts = append(whereOpts, service_options.WithWhereRegexOption())
	}
	if c.prefix {
		whereOpts = append(whereOpts, service_options.WithWherePrefixOption())
	}
	peers, err := facade.WhereIsServiceName(serviceName, whereOpts...)
	if err != nil {
		return nil, err
	}
	result := &GetSubchannelResponse_MulticastResult{}
	result.peerCount = len(peers)
	for _, peer := range peers {
		var address string
		if facade.IsEnableResolver() {
			address = peer.Url
		} else {
			address = peer.Address
		}
		client, err := c.client.getClient(address)
		if err != nil {
			result.errors = append(result.errors, err)
			result.errorPeers = append(result.errorPeers, peer)
			continue
		}
		out, err := client.GetSubchannel(ctx, in, opts...)
		if err != nil {
			result.errors = append(result.errors, err)
			result.errorPeers = append(result.errorPeers, peer)
			c.client.putClient(address, client)
			continue
		}
		c.client.putClient(address, client)
		result.responses = append(result.responses, out)
		result.successPeers = append(result.successPeers, peer)
	}
	return result, nil
}

func (c *channelzClientsMulticast) GetSocket(ctx context.Context, in *grpc_channelz_v1.GetSocketRequest, opts ...grpc.CallOption) (*GetSocketResponse_MulticastResult, error) {
	var peers []*gira.Peer
	var whereOpts []service_options.WhereOption
	// 多播
	whereOpts = append(whereOpts, service_options.WithWhereCatalogOption())
	if c.count > 0 {
		whereOpts = append(whereOpts, service_options.WithWhereMaxCountOption(c.count))
	}
	serviceName := c.serviceName
	if len(c.regex) > 0 {
		serviceName = fmt.Sprintf("%s%s", c.serviceName, c.regex)
		whereOpts = append(whereOpts, service_options.WithWhereRegexOption())
	}
	if c.prefix {
		whereOpts = append(whereOpts, service_options.WithWherePrefixOption())
	}
	peers, err := facade.WhereIsServiceName(serviceName, whereOpts...)
	if err != nil {
		return nil, err
	}
	result := &GetSocketResponse_MulticastResult{}
	result.peerCount = len(peers)
	for _, peer := range peers {
		var address string
		if facade.IsEnableResolver() {
			address = peer.Url
		} else {
			address = peer.Address
		}
		client, err := c.client.getClient(address)
		if err != nil {
			result.errors = append(result.errors, err)
			result.errorPeers = append(result.errorPeers, peer)
			continue
		}
		out, err := client.GetSocket(ctx, in, opts...)
		if err != nil {
			result.errors = append(result.errors, err)
			result.errorPeers = append(result.errorPeers, peer)
			c.client.putClient(address, client)
			continue
		}
		c.client.putClient(address, client)
		result.responses = append(result.responses, out)
		result.successPeers = append(result.successPeers, peer)
	}
	return result, nil
}
