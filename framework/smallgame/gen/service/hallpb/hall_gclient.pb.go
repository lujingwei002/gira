// Code generated by protoc-gen-go-gclient. DO NOT EDIT.
// versions:
// - protoc-gen-go-gclient v1.3.0
// - protoc             v3.12.4
// source: doc/service/hall.proto

package hallpb

import (
	context "context"
	fmt "fmt"
	gira "github.com/lujingwei002/gira"
	errors "github.com/lujingwei002/gira/errors"
	facade "github.com/lujingwei002/gira/facade"
	service_options "github.com/lujingwei002/gira/options/service_options"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	metadata "google.golang.org/grpc/metadata"
	status "google.golang.org/grpc/status"
	sync "sync"
	time "time"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

type ClientMessageResponse_MulticastResult struct {
	errors       []error
	peerCount    int
	successPeers []*gira.Peer
	errorPeers   []*gira.Peer
	responses    []*ClientMessageResponse
}

func (r *ClientMessageResponse_MulticastResult) Error() error {
	if len(r.errors) <= 0 {
		return nil
	}
	return r.errors[0]
}
func (r *ClientMessageResponse_MulticastResult) Response(index int) *ClientMessageResponse {
	if index < 0 || index >= len(r.responses) {
		return nil
	}
	return r.responses[index]
}
func (r *ClientMessageResponse_MulticastResult) SuccessPeer(index int) *gira.Peer {
	if index < 0 || index >= len(r.successPeers) {
		return nil
	}
	return r.successPeers[index]
}
func (r *ClientMessageResponse_MulticastResult) ErrorPeer(index int) *gira.Peer {
	if index < 0 || index >= len(r.errorPeers) {
		return nil
	}
	return r.errorPeers[index]
}
func (r *ClientMessageResponse_MulticastResult) PeerCount() int {
	return r.peerCount
}
func (r *ClientMessageResponse_MulticastResult) SuccessCount() int {
	return len(r.successPeers)
}
func (r *ClientMessageResponse_MulticastResult) ErrorCount() int {
	return len(r.errorPeers)
}
func (r *ClientMessageResponse_MulticastResult) Errors(index int) error {
	if index < 0 || index >= len(r.errors) {
		return nil
	}
	return r.errors[index]
}

type GateStreamResponse_MulticastResult struct {
	errors       []error
	peerCount    int
	successPeers []*gira.Peer
	errorPeers   []*gira.Peer
	responses    []*GateStreamResponse
}

func (r *GateStreamResponse_MulticastResult) Error() error {
	if len(r.errors) <= 0 {
		return nil
	}
	return r.errors[0]
}
func (r *GateStreamResponse_MulticastResult) Response(index int) *GateStreamResponse {
	if index < 0 || index >= len(r.responses) {
		return nil
	}
	return r.responses[index]
}
func (r *GateStreamResponse_MulticastResult) SuccessPeer(index int) *gira.Peer {
	if index < 0 || index >= len(r.successPeers) {
		return nil
	}
	return r.successPeers[index]
}
func (r *GateStreamResponse_MulticastResult) ErrorPeer(index int) *gira.Peer {
	if index < 0 || index >= len(r.errorPeers) {
		return nil
	}
	return r.errorPeers[index]
}
func (r *GateStreamResponse_MulticastResult) PeerCount() int {
	return r.peerCount
}
func (r *GateStreamResponse_MulticastResult) SuccessCount() int {
	return len(r.successPeers)
}
func (r *GateStreamResponse_MulticastResult) ErrorCount() int {
	return len(r.errorPeers)
}
func (r *GateStreamResponse_MulticastResult) Errors(index int) error {
	if index < 0 || index >= len(r.errors) {
		return nil
	}
	return r.errors[index]
}

type InfoResponse_MulticastResult struct {
	errors       []error
	peerCount    int
	successPeers []*gira.Peer
	errorPeers   []*gira.Peer
	responses    []*InfoResponse
}

func (r *InfoResponse_MulticastResult) Error() error {
	if len(r.errors) <= 0 {
		return nil
	}
	return r.errors[0]
}
func (r *InfoResponse_MulticastResult) Response(index int) *InfoResponse {
	if index < 0 || index >= len(r.responses) {
		return nil
	}
	return r.responses[index]
}
func (r *InfoResponse_MulticastResult) SuccessPeer(index int) *gira.Peer {
	if index < 0 || index >= len(r.successPeers) {
		return nil
	}
	return r.successPeers[index]
}
func (r *InfoResponse_MulticastResult) ErrorPeer(index int) *gira.Peer {
	if index < 0 || index >= len(r.errorPeers) {
		return nil
	}
	return r.errorPeers[index]
}
func (r *InfoResponse_MulticastResult) PeerCount() int {
	return r.peerCount
}
func (r *InfoResponse_MulticastResult) SuccessCount() int {
	return len(r.successPeers)
}
func (r *InfoResponse_MulticastResult) ErrorCount() int {
	return len(r.errorPeers)
}
func (r *InfoResponse_MulticastResult) Errors(index int) error {
	if index < 0 || index >= len(r.errors) {
		return nil
	}
	return r.errors[index]
}

type HealthCheckResponse_MulticastResult struct {
	errors       []error
	peerCount    int
	successPeers []*gira.Peer
	errorPeers   []*gira.Peer
	responses    []*HealthCheckResponse
}

func (r *HealthCheckResponse_MulticastResult) Error() error {
	if len(r.errors) <= 0 {
		return nil
	}
	return r.errors[0]
}
func (r *HealthCheckResponse_MulticastResult) Response(index int) *HealthCheckResponse {
	if index < 0 || index >= len(r.responses) {
		return nil
	}
	return r.responses[index]
}
func (r *HealthCheckResponse_MulticastResult) SuccessPeer(index int) *gira.Peer {
	if index < 0 || index >= len(r.successPeers) {
		return nil
	}
	return r.successPeers[index]
}
func (r *HealthCheckResponse_MulticastResult) ErrorPeer(index int) *gira.Peer {
	if index < 0 || index >= len(r.errorPeers) {
		return nil
	}
	return r.errorPeers[index]
}
func (r *HealthCheckResponse_MulticastResult) PeerCount() int {
	return r.peerCount
}
func (r *HealthCheckResponse_MulticastResult) SuccessCount() int {
	return len(r.successPeers)
}
func (r *HealthCheckResponse_MulticastResult) ErrorCount() int {
	return len(r.errorPeers)
}
func (r *HealthCheckResponse_MulticastResult) Errors(index int) error {
	if index < 0 || index >= len(r.errors) {
		return nil
	}
	return r.errors[index]
}

type MustPushResponse_MulticastResult struct {
	errors       []error
	peerCount    int
	successPeers []*gira.Peer
	errorPeers   []*gira.Peer
	responses    []*MustPushResponse
}

func (r *MustPushResponse_MulticastResult) Error() error {
	if len(r.errors) <= 0 {
		return nil
	}
	return r.errors[0]
}
func (r *MustPushResponse_MulticastResult) Response(index int) *MustPushResponse {
	if index < 0 || index >= len(r.responses) {
		return nil
	}
	return r.responses[index]
}
func (r *MustPushResponse_MulticastResult) SuccessPeer(index int) *gira.Peer {
	if index < 0 || index >= len(r.successPeers) {
		return nil
	}
	return r.successPeers[index]
}
func (r *MustPushResponse_MulticastResult) ErrorPeer(index int) *gira.Peer {
	if index < 0 || index >= len(r.errorPeers) {
		return nil
	}
	return r.errorPeers[index]
}
func (r *MustPushResponse_MulticastResult) PeerCount() int {
	return r.peerCount
}
func (r *MustPushResponse_MulticastResult) SuccessCount() int {
	return len(r.successPeers)
}
func (r *MustPushResponse_MulticastResult) ErrorCount() int {
	return len(r.errorPeers)
}
func (r *MustPushResponse_MulticastResult) Errors(index int) error {
	if index < 0 || index >= len(r.errors) {
		return nil
	}
	return r.errors[index]
}

type SendMessageResponse_MulticastResult struct {
	errors       []error
	peerCount    int
	successPeers []*gira.Peer
	errorPeers   []*gira.Peer
	responses    []*SendMessageResponse
}

func (r *SendMessageResponse_MulticastResult) Error() error {
	if len(r.errors) <= 0 {
		return nil
	}
	return r.errors[0]
}
func (r *SendMessageResponse_MulticastResult) Response(index int) *SendMessageResponse {
	if index < 0 || index >= len(r.responses) {
		return nil
	}
	return r.responses[index]
}
func (r *SendMessageResponse_MulticastResult) SuccessPeer(index int) *gira.Peer {
	if index < 0 || index >= len(r.successPeers) {
		return nil
	}
	return r.successPeers[index]
}
func (r *SendMessageResponse_MulticastResult) ErrorPeer(index int) *gira.Peer {
	if index < 0 || index >= len(r.errorPeers) {
		return nil
	}
	return r.errorPeers[index]
}
func (r *SendMessageResponse_MulticastResult) PeerCount() int {
	return r.peerCount
}
func (r *SendMessageResponse_MulticastResult) SuccessCount() int {
	return len(r.successPeers)
}
func (r *SendMessageResponse_MulticastResult) ErrorCount() int {
	return len(r.errorPeers)
}
func (r *SendMessageResponse_MulticastResult) Errors(index int) error {
	if index < 0 || index >= len(r.errors) {
		return nil
	}
	return r.errors[index]
}

type CallMessageResponse_MulticastResult struct {
	errors       []error
	peerCount    int
	successPeers []*gira.Peer
	errorPeers   []*gira.Peer
	responses    []*CallMessageResponse
}

func (r *CallMessageResponse_MulticastResult) Error() error {
	if len(r.errors) <= 0 {
		return nil
	}
	return r.errors[0]
}
func (r *CallMessageResponse_MulticastResult) Response(index int) *CallMessageResponse {
	if index < 0 || index >= len(r.responses) {
		return nil
	}
	return r.responses[index]
}
func (r *CallMessageResponse_MulticastResult) SuccessPeer(index int) *gira.Peer {
	if index < 0 || index >= len(r.successPeers) {
		return nil
	}
	return r.successPeers[index]
}
func (r *CallMessageResponse_MulticastResult) ErrorPeer(index int) *gira.Peer {
	if index < 0 || index >= len(r.errorPeers) {
		return nil
	}
	return r.errorPeers[index]
}
func (r *CallMessageResponse_MulticastResult) PeerCount() int {
	return r.peerCount
}
func (r *CallMessageResponse_MulticastResult) SuccessCount() int {
	return len(r.successPeers)
}
func (r *CallMessageResponse_MulticastResult) ErrorCount() int {
	return len(r.errorPeers)
}
func (r *CallMessageResponse_MulticastResult) Errors(index int) error {
	if index < 0 || index >= len(r.errors) {
		return nil
	}
	return r.errors[index]
}

type UserInsteadResponse_MulticastResult struct {
	errors       []error
	peerCount    int
	successPeers []*gira.Peer
	errorPeers   []*gira.Peer
	responses    []*UserInsteadResponse
}

func (r *UserInsteadResponse_MulticastResult) Error() error {
	if len(r.errors) <= 0 {
		return nil
	}
	return r.errors[0]
}
func (r *UserInsteadResponse_MulticastResult) Response(index int) *UserInsteadResponse {
	if index < 0 || index >= len(r.responses) {
		return nil
	}
	return r.responses[index]
}
func (r *UserInsteadResponse_MulticastResult) SuccessPeer(index int) *gira.Peer {
	if index < 0 || index >= len(r.successPeers) {
		return nil
	}
	return r.successPeers[index]
}
func (r *UserInsteadResponse_MulticastResult) ErrorPeer(index int) *gira.Peer {
	if index < 0 || index >= len(r.errorPeers) {
		return nil
	}
	return r.errorPeers[index]
}
func (r *UserInsteadResponse_MulticastResult) PeerCount() int {
	return r.peerCount
}
func (r *UserInsteadResponse_MulticastResult) SuccessCount() int {
	return len(r.successPeers)
}
func (r *UserInsteadResponse_MulticastResult) ErrorCount() int {
	return len(r.errorPeers)
}
func (r *UserInsteadResponse_MulticastResult) Errors(index int) error {
	if index < 0 || index >= len(r.errors) {
		return nil
	}
	return r.errors[index]
}

type KickResponse_MulticastResult struct {
	errors       []error
	peerCount    int
	successPeers []*gira.Peer
	errorPeers   []*gira.Peer
	responses    []*KickResponse
}

func (r *KickResponse_MulticastResult) Error() error {
	if len(r.errors) <= 0 {
		return nil
	}
	return r.errors[0]
}
func (r *KickResponse_MulticastResult) Response(index int) *KickResponse {
	if index < 0 || index >= len(r.responses) {
		return nil
	}
	return r.responses[index]
}
func (r *KickResponse_MulticastResult) SuccessPeer(index int) *gira.Peer {
	if index < 0 || index >= len(r.successPeers) {
		return nil
	}
	return r.successPeers[index]
}
func (r *KickResponse_MulticastResult) ErrorPeer(index int) *gira.Peer {
	if index < 0 || index >= len(r.errorPeers) {
		return nil
	}
	return r.errorPeers[index]
}
func (r *KickResponse_MulticastResult) PeerCount() int {
	return r.peerCount
}
func (r *KickResponse_MulticastResult) SuccessCount() int {
	return len(r.successPeers)
}
func (r *KickResponse_MulticastResult) ErrorCount() int {
	return len(r.errorPeers)
}
func (r *KickResponse_MulticastResult) Errors(index int) error {
	if index < 0 || index >= len(r.errors) {
		return nil
	}
	return r.errors[index]
}

const (
	HallServerName = "hallpb.Hall"
)

// HallClient is the client API for Hall service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type HallClients interface {
	WithServiceName(serviceName string) HallClients
	// 发送到一个节点
	Unicast() HallClientsUnicast
	Multicast(count int) HallClientsMulticast
	// 广播给所有节点
	Broadcast() HallClientsMulticast

	// client消息流
	ClientStream(ctx context.Context, address string, opts ...grpc.CallOption) (Hall_ClientStreamClient, error)
	// 网关消息流
	GateStream(ctx context.Context, address string, opts ...grpc.CallOption) (Hall_GateStreamClient, error)
	// 状态
	Info(ctx context.Context, address string, in *InfoRequest, opts ...grpc.CallOption) (*InfoResponse, error)
	// 心跳
	HealthCheck(ctx context.Context, address string, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error)
	// rpc PushStream (stream PushStreamNotify) returns (PushStreamPush) {}
	MustPush(ctx context.Context, address string, in *MustPushRequest, opts ...grpc.CallOption) (*MustPushResponse, error)
	// 发送消息
	SendMessage(ctx context.Context, address string, in *SendMessageRequest, opts ...grpc.CallOption) (*SendMessageResponse, error)
	// 发送消息
	CallMessage(ctx context.Context, address string, in *CallMessageRequest, opts ...grpc.CallOption) (*CallMessageResponse, error)
	// 顶号下线
	UserInstead(ctx context.Context, address string, in *UserInsteadRequest, opts ...grpc.CallOption) (*UserInsteadResponse, error)
	// 踢人下线
	Kick(ctx context.Context, address string, in *KickRequest, opts ...grpc.CallOption) (*KickResponse, error)
}

type HallClientsMulticast interface {
	WhereRegex(regex string) HallClientsMulticast
	WherePrefix(prefix bool) HallClientsMulticast
	Local() HallClientsMulticast
	// client消息流
	ClientStream(ctx context.Context, opts ...grpc.CallOption) (*Hall_ClientStreamClient_MulticastResult, error)
	// 网关消息流
	GateStream(ctx context.Context, opts ...grpc.CallOption) (*Hall_GateStreamClient_MulticastResult, error)
	// 状态
	Info(ctx context.Context, in *InfoRequest, opts ...grpc.CallOption) (*InfoResponse_MulticastResult, error)
	// 心跳
	HealthCheck(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse_MulticastResult, error)
	// rpc PushStream (stream PushStreamNotify) returns (PushStreamPush) {}
	MustPush(ctx context.Context, in *MustPushRequest, opts ...grpc.CallOption) (*MustPushResponse_MulticastResult, error)
	// 发送消息
	SendMessage(ctx context.Context, in *SendMessageRequest, opts ...grpc.CallOption) (*SendMessageResponse_MulticastResult, error)
	// 发送消息
	CallMessage(ctx context.Context, in *CallMessageRequest, opts ...grpc.CallOption) (*CallMessageResponse_MulticastResult, error)
	// 顶号下线
	UserInstead(ctx context.Context, in *UserInsteadRequest, opts ...grpc.CallOption) (*UserInsteadResponse_MulticastResult, error)
	// 踢人下线
	Kick(ctx context.Context, in *KickRequest, opts ...grpc.CallOption) (*KickResponse_MulticastResult, error)
}

type HallClientsUnicast interface {
	Where(serviceName string) HallClientsUnicast
	WherePeer(peer *gira.Peer) HallClientsUnicast
	WherePeerFullName(appFullName string) HallClientsUnicast
	WhereAddress(address string) HallClientsUnicast
	WhereUser(userId string) HallClientsUnicast
	Local() HallClientsUnicast

	// client消息流
	ClientStream(ctx context.Context, opts ...grpc.CallOption) (Hall_ClientStreamClient, error)
	// 网关消息流
	GateStream(ctx context.Context, opts ...grpc.CallOption) (Hall_GateStreamClient, error)
	// 状态
	Info(ctx context.Context, in *InfoRequest, opts ...grpc.CallOption) (*InfoResponse, error)
	// 心跳
	HealthCheck(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error)
	// rpc PushStream (stream PushStreamNotify) returns (PushStreamPush) {}
	MustPush(ctx context.Context, in *MustPushRequest, opts ...grpc.CallOption) (*MustPushResponse, error)
	// 发送消息
	SendMessage(ctx context.Context, in *SendMessageRequest, opts ...grpc.CallOption) (*SendMessageResponse, error)
	// 发送消息
	CallMessage(ctx context.Context, in *CallMessageRequest, opts ...grpc.CallOption) (*CallMessageResponse, error)
	// 顶号下线
	UserInstead(ctx context.Context, in *UserInsteadRequest, opts ...grpc.CallOption) (*UserInsteadResponse, error)
	// 踢人下线
	Kick(ctx context.Context, in *KickRequest, opts ...grpc.CallOption) (*KickResponse, error)
}

type hallClients struct {
	mu          sync.Mutex
	clientPool  map[string]*sync.Pool
	serviceName string
}

func NewHallClients() HallClients {
	return &hallClients{
		serviceName: HallServerName,
		clientPool:  make(map[string]*sync.Pool, 0),
	}
}

var DefaultHallClients = NewHallClients()

func (c *hallClients) getClient(address string) (HallClient, error) {
	c.mu.Lock()
	var pool *sync.Pool
	var ok bool
	if pool, ok = c.clientPool[address]; !ok {
		pool = &sync.Pool{
			New: func() any {
				conn, err := grpc.Dial(address, grpc.WithInsecure())
				if err != nil {
					return err
				}
				client := NewHallClient(conn)
				return client
			},
		}
		c.clientPool[address] = pool
		c.mu.Unlock()
	} else {
		c.mu.Unlock()
	}
	if v := pool.Get(); v == nil {
		return nil, errors.ErrGrpcClientPoolNil
	} else if err, ok := v.(error); ok {
		return nil, err
	} else {
		return v.(HallClient), nil
	}
}

func (c *hallClients) putClient(address string, client HallClient) {
	c.mu.Lock()
	var pool *sync.Pool
	var ok bool
	if pool, ok = c.clientPool[address]; ok {
		pool.Put(client)
	}
	c.mu.Unlock()
}

func (c *hallClients) WithServiceName(serviceName string) HallClients {
	c.serviceName = serviceName
	return c
}

func (c *hallClients) Unicast() HallClientsUnicast {
	headers := make(map[string]string)
	u := &hallClientsUnicast{
		timeout: 5,
		headers: metadata.New(headers),
		client:  c,
	}
	return u
}

func (c *hallClients) Multicast(count int) HallClientsMulticast {
	headers := make(map[string]string)
	u := &hallClientsMulticast{
		timeout:     5,
		count:       count,
		headers:     metadata.New(headers),
		serviceName: fmt.Sprintf("%s/", c.serviceName),
		client:      c,
	}
	return u
}

func (c *hallClients) Broadcast() HallClientsMulticast {
	u := &hallClientsMulticast{
		count:       -1,
		serviceName: fmt.Sprintf("%s/", c.serviceName),
		client:      c,
	}
	return u
}

func (c *hallClients) ClientStream(ctx context.Context, address string, opts ...grpc.CallOption) (Hall_ClientStreamClient, error) {
	client, err := c.getClient(address)
	if err != nil {
		return nil, err
	}
	defer c.putClient(address, client)
	out, err := client.ClientStream(ctx, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hallClients) GateStream(ctx context.Context, address string, opts ...grpc.CallOption) (Hall_GateStreamClient, error) {
	client, err := c.getClient(address)
	if err != nil {
		return nil, err
	}
	defer c.putClient(address, client)
	out, err := client.GateStream(ctx, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hallClients) Info(ctx context.Context, address string, in *InfoRequest, opts ...grpc.CallOption) (*InfoResponse, error) {
	client, err := c.getClient(address)
	if err != nil {
		return nil, err
	}
	defer c.putClient(address, client)
	out, err := client.Info(ctx, in, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hallClients) HealthCheck(ctx context.Context, address string, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error) {
	client, err := c.getClient(address)
	if err != nil {
		return nil, err
	}
	defer c.putClient(address, client)
	out, err := client.HealthCheck(ctx, in, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hallClients) MustPush(ctx context.Context, address string, in *MustPushRequest, opts ...grpc.CallOption) (*MustPushResponse, error) {
	client, err := c.getClient(address)
	if err != nil {
		return nil, err
	}
	defer c.putClient(address, client)
	out, err := client.MustPush(ctx, in, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hallClients) SendMessage(ctx context.Context, address string, in *SendMessageRequest, opts ...grpc.CallOption) (*SendMessageResponse, error) {
	client, err := c.getClient(address)
	if err != nil {
		return nil, err
	}
	defer c.putClient(address, client)
	out, err := client.SendMessage(ctx, in, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hallClients) CallMessage(ctx context.Context, address string, in *CallMessageRequest, opts ...grpc.CallOption) (*CallMessageResponse, error) {
	client, err := c.getClient(address)
	if err != nil {
		return nil, err
	}
	defer c.putClient(address, client)
	out, err := client.CallMessage(ctx, in, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hallClients) UserInstead(ctx context.Context, address string, in *UserInsteadRequest, opts ...grpc.CallOption) (*UserInsteadResponse, error) {
	client, err := c.getClient(address)
	if err != nil {
		return nil, err
	}
	defer c.putClient(address, client)
	out, err := client.UserInstead(ctx, in, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hallClients) Kick(ctx context.Context, address string, in *KickRequest, opts ...grpc.CallOption) (*KickResponse, error) {
	client, err := c.getClient(address)
	if err != nil {
		return nil, err
	}
	defer c.putClient(address, client)
	out, err := client.Kick(ctx, in, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

type hallClientsUnicast struct {
	timeout      int64
	peer         *gira.Peer
	peerFullName string
	serviceName  string
	address      string
	userId       string
	local        bool
	client       *hallClients
	headers      metadata.MD
}

func (c *hallClientsUnicast) Local() HallClientsUnicast {
	c.local = true
	return c
}

func (c *hallClientsUnicast) Where(serviceName string) HallClientsUnicast {
	c.serviceName = serviceName
	return c
}

func (c *hallClientsUnicast) WherePeer(peer *gira.Peer) HallClientsUnicast {
	c.peer = peer
	return c
}

func (c *hallClientsUnicast) WherePeerFullName(peerFullName string) HallClientsUnicast {
	c.peerFullName = peerFullName
	return c
}

func (c *hallClientsUnicast) WhereAddress(address string) HallClientsUnicast {
	c.address = address
	return c
}

func (c *hallClientsUnicast) WhereUser(userId string) HallClientsUnicast {
	c.userId = userId
	c.headers.Set(gira.GRPC_PATH_KEY, userId)
	return c
}

func (c *hallClientsUnicast) ClientStream(ctx context.Context, opts ...grpc.CallOption) (Hall_ClientStreamClient, error) {
	if c.local {
		return nil, status.Errorf(codes.Unimplemented, "method ClientStream not implemented")

	} else {
		var address string
		if len(c.address) > 0 {
			address = c.address
		} else if len(c.peerFullName) > 0 {
			if peer, err := facade.WhereIsPeer(c.peerFullName); err != nil {
				return nil, err
			} else if facade.IsEnableResolver() {
				address = peer.Url
			} else {
				address = peer.Address
			}
		} else if c.peer != nil && facade.IsEnableResolver() {
			address = c.peer.Url
		} else if c.peer != nil {
			address = c.peer.Address
		} else if len(c.serviceName) > 0 {
			if peers, err := facade.WhereIsServiceName(c.serviceName); err != nil {
				return nil, err
			} else if len(peers) < 1 {
				return nil, errors.ErrPeerNotFound
			} else if facade.IsEnableResolver() {
				address = peers[0].Url
			} else {
				address = peers[0].Address
			}
		} else if len(c.userId) > 0 {
			if peer, err := facade.WhereIsUser(c.userId); err != nil {
				return nil, err
			} else if facade.IsEnableResolver() {
				address = peer.Url
			} else {
				address = peer.Address
			}
		}
		if len(address) <= 0 {
			return nil, errors.ErrPeerNotFound
		}
		client, err := c.client.getClient(address)
		if err != nil {
			return nil, err
		}
		defer c.client.putClient(address, client)
		if c.headers.Len() > 0 {
			ctx = metadata.NewOutgoingContext(ctx, c.headers)
		}
		out, err := client.ClientStream(ctx, opts...)
		if err != nil {
			return nil, err
		}
		return out, nil
	}

}
func (c *hallClientsUnicast) GateStream(ctx context.Context, opts ...grpc.CallOption) (Hall_GateStreamClient, error) {
	if c.local {
		return nil, status.Errorf(codes.Unimplemented, "method GateStream not implemented")

	} else {
		var address string
		if len(c.address) > 0 {
			address = c.address
		} else if len(c.peerFullName) > 0 {
			if peer, err := facade.WhereIsPeer(c.peerFullName); err != nil {
				return nil, err
			} else if facade.IsEnableResolver() {
				address = peer.Url
			} else {
				address = peer.Address
			}
		} else if c.peer != nil && facade.IsEnableResolver() {
			address = c.peer.Url
		} else if c.peer != nil {
			address = c.peer.Address
		} else if len(c.serviceName) > 0 {
			if peers, err := facade.WhereIsServiceName(c.serviceName); err != nil {
				return nil, err
			} else if len(peers) < 1 {
				return nil, errors.ErrPeerNotFound
			} else if facade.IsEnableResolver() {
				address = peers[0].Url
			} else {
				address = peers[0].Address
			}
		} else if len(c.userId) > 0 {
			if peer, err := facade.WhereIsUser(c.userId); err != nil {
				return nil, err
			} else if facade.IsEnableResolver() {
				address = peer.Url
			} else {
				address = peer.Address
			}
		}
		if len(address) <= 0 {
			return nil, errors.ErrPeerNotFound
		}
		client, err := c.client.getClient(address)
		if err != nil {
			return nil, err
		}
		defer c.client.putClient(address, client)
		if c.headers.Len() > 0 {
			ctx = metadata.NewOutgoingContext(ctx, c.headers)
		}
		out, err := client.GateStream(ctx, opts...)
		if err != nil {
			return nil, err
		}
		return out, nil
	}

}
func (c *hallClientsUnicast) Info(ctx context.Context, in *InfoRequest, opts ...grpc.CallOption) (*InfoResponse, error) {
	if c.local {
		cancelCtx, cancelFunc := context.WithTimeout(ctx, time.Second*time.Duration(c.timeout))
		defer cancelFunc()
		if c.headers.Len() > 0 {
			cancelCtx = metadata.NewOutgoingContext(cancelCtx, c.headers)
		}
		if s, ok := facade.WhereIsServer(c.client.serviceName); !ok {
			return nil, errors.ErrServerNotFound
		} else if svr, ok := s.(HallServer); !ok {
			return nil, errors.ErrServerNotFound
		} else {
			return svr.Info(cancelCtx, in)
		}

	} else {
		var address string
		if len(c.address) > 0 {
			address = c.address
		} else if len(c.peerFullName) > 0 {
			if peer, err := facade.WhereIsPeer(c.peerFullName); err != nil {
				return nil, err
			} else if facade.IsEnableResolver() {
				address = peer.Url
			} else {
				address = peer.Address
			}
		} else if c.peer != nil && facade.IsEnableResolver() {
			address = c.peer.Url
		} else if c.peer != nil {
			address = c.peer.Address
		} else if len(c.serviceName) > 0 {
			if peers, err := facade.WhereIsServiceName(c.serviceName); err != nil {
				return nil, err
			} else if len(peers) < 1 {
				return nil, errors.ErrPeerNotFound
			} else if facade.IsEnableResolver() {
				address = peers[0].Url
			} else {
				address = peers[0].Address
			}
		} else if len(c.userId) > 0 {
			if peer, err := facade.WhereIsUser(c.userId); err != nil {
				return nil, err
			} else if facade.IsEnableResolver() {
				address = peer.Url
			} else {
				address = peer.Address
			}
		}
		if len(address) <= 0 {
			return nil, errors.ErrPeerNotFound
		}
		client, err := c.client.getClient(address)
		if err != nil {
			return nil, err
		}
		defer c.client.putClient(address, client)
		if c.headers.Len() > 0 {
			ctx = metadata.NewOutgoingContext(ctx, c.headers)
		}
		out, err := client.Info(ctx, in, opts...)
		if err != nil {
			return nil, err
		}
		return out, nil
	}

}
func (c *hallClientsUnicast) HealthCheck(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error) {
	if c.local {
		cancelCtx, cancelFunc := context.WithTimeout(ctx, time.Second*time.Duration(c.timeout))
		defer cancelFunc()
		if c.headers.Len() > 0 {
			cancelCtx = metadata.NewOutgoingContext(cancelCtx, c.headers)
		}
		if s, ok := facade.WhereIsServer(c.client.serviceName); !ok {
			return nil, errors.ErrServerNotFound
		} else if svr, ok := s.(HallServer); !ok {
			return nil, errors.ErrServerNotFound
		} else {
			return svr.HealthCheck(cancelCtx, in)
		}

	} else {
		var address string
		if len(c.address) > 0 {
			address = c.address
		} else if len(c.peerFullName) > 0 {
			if peer, err := facade.WhereIsPeer(c.peerFullName); err != nil {
				return nil, err
			} else if facade.IsEnableResolver() {
				address = peer.Url
			} else {
				address = peer.Address
			}
		} else if c.peer != nil && facade.IsEnableResolver() {
			address = c.peer.Url
		} else if c.peer != nil {
			address = c.peer.Address
		} else if len(c.serviceName) > 0 {
			if peers, err := facade.WhereIsServiceName(c.serviceName); err != nil {
				return nil, err
			} else if len(peers) < 1 {
				return nil, errors.ErrPeerNotFound
			} else if facade.IsEnableResolver() {
				address = peers[0].Url
			} else {
				address = peers[0].Address
			}
		} else if len(c.userId) > 0 {
			if peer, err := facade.WhereIsUser(c.userId); err != nil {
				return nil, err
			} else if facade.IsEnableResolver() {
				address = peer.Url
			} else {
				address = peer.Address
			}
		}
		if len(address) <= 0 {
			return nil, errors.ErrPeerNotFound
		}
		client, err := c.client.getClient(address)
		if err != nil {
			return nil, err
		}
		defer c.client.putClient(address, client)
		if c.headers.Len() > 0 {
			ctx = metadata.NewOutgoingContext(ctx, c.headers)
		}
		out, err := client.HealthCheck(ctx, in, opts...)
		if err != nil {
			return nil, err
		}
		return out, nil
	}

}
func (c *hallClientsUnicast) MustPush(ctx context.Context, in *MustPushRequest, opts ...grpc.CallOption) (*MustPushResponse, error) {
	if c.local {
		cancelCtx, cancelFunc := context.WithTimeout(ctx, time.Second*time.Duration(c.timeout))
		defer cancelFunc()
		if c.headers.Len() > 0 {
			cancelCtx = metadata.NewOutgoingContext(cancelCtx, c.headers)
		}
		if s, ok := facade.WhereIsServer(c.client.serviceName); !ok {
			return nil, errors.ErrServerNotFound
		} else if svr, ok := s.(HallServer); !ok {
			return nil, errors.ErrServerNotFound
		} else {
			return svr.MustPush(cancelCtx, in)
		}

	} else {
		var address string
		if len(c.address) > 0 {
			address = c.address
		} else if len(c.peerFullName) > 0 {
			if peer, err := facade.WhereIsPeer(c.peerFullName); err != nil {
				return nil, err
			} else if facade.IsEnableResolver() {
				address = peer.Url
			} else {
				address = peer.Address
			}
		} else if c.peer != nil && facade.IsEnableResolver() {
			address = c.peer.Url
		} else if c.peer != nil {
			address = c.peer.Address
		} else if len(c.serviceName) > 0 {
			if peers, err := facade.WhereIsServiceName(c.serviceName); err != nil {
				return nil, err
			} else if len(peers) < 1 {
				return nil, errors.ErrPeerNotFound
			} else if facade.IsEnableResolver() {
				address = peers[0].Url
			} else {
				address = peers[0].Address
			}
		} else if len(c.userId) > 0 {
			if peer, err := facade.WhereIsUser(c.userId); err != nil {
				return nil, err
			} else if facade.IsEnableResolver() {
				address = peer.Url
			} else {
				address = peer.Address
			}
		}
		if len(address) <= 0 {
			return nil, errors.ErrPeerNotFound
		}
		client, err := c.client.getClient(address)
		if err != nil {
			return nil, err
		}
		defer c.client.putClient(address, client)
		if c.headers.Len() > 0 {
			ctx = metadata.NewOutgoingContext(ctx, c.headers)
		}
		out, err := client.MustPush(ctx, in, opts...)
		if err != nil {
			return nil, err
		}
		return out, nil
	}

}
func (c *hallClientsUnicast) SendMessage(ctx context.Context, in *SendMessageRequest, opts ...grpc.CallOption) (*SendMessageResponse, error) {
	if c.local {
		cancelCtx, cancelFunc := context.WithTimeout(ctx, time.Second*time.Duration(c.timeout))
		defer cancelFunc()
		if c.headers.Len() > 0 {
			cancelCtx = metadata.NewOutgoingContext(cancelCtx, c.headers)
		}
		if s, ok := facade.WhereIsServer(c.client.serviceName); !ok {
			return nil, errors.ErrServerNotFound
		} else if svr, ok := s.(HallServer); !ok {
			return nil, errors.ErrServerNotFound
		} else {
			return svr.SendMessage(cancelCtx, in)
		}

	} else {
		var address string
		if len(c.address) > 0 {
			address = c.address
		} else if len(c.peerFullName) > 0 {
			if peer, err := facade.WhereIsPeer(c.peerFullName); err != nil {
				return nil, err
			} else if facade.IsEnableResolver() {
				address = peer.Url
			} else {
				address = peer.Address
			}
		} else if c.peer != nil && facade.IsEnableResolver() {
			address = c.peer.Url
		} else if c.peer != nil {
			address = c.peer.Address
		} else if len(c.serviceName) > 0 {
			if peers, err := facade.WhereIsServiceName(c.serviceName); err != nil {
				return nil, err
			} else if len(peers) < 1 {
				return nil, errors.ErrPeerNotFound
			} else if facade.IsEnableResolver() {
				address = peers[0].Url
			} else {
				address = peers[0].Address
			}
		} else if len(c.userId) > 0 {
			if peer, err := facade.WhereIsUser(c.userId); err != nil {
				return nil, err
			} else if facade.IsEnableResolver() {
				address = peer.Url
			} else {
				address = peer.Address
			}
		}
		if len(address) <= 0 {
			return nil, errors.ErrPeerNotFound
		}
		client, err := c.client.getClient(address)
		if err != nil {
			return nil, err
		}
		defer c.client.putClient(address, client)
		if c.headers.Len() > 0 {
			ctx = metadata.NewOutgoingContext(ctx, c.headers)
		}
		out, err := client.SendMessage(ctx, in, opts...)
		if err != nil {
			return nil, err
		}
		return out, nil
	}

}
func (c *hallClientsUnicast) CallMessage(ctx context.Context, in *CallMessageRequest, opts ...grpc.CallOption) (*CallMessageResponse, error) {
	if c.local {
		cancelCtx, cancelFunc := context.WithTimeout(ctx, time.Second*time.Duration(c.timeout))
		defer cancelFunc()
		if c.headers.Len() > 0 {
			cancelCtx = metadata.NewOutgoingContext(cancelCtx, c.headers)
		}
		if s, ok := facade.WhereIsServer(c.client.serviceName); !ok {
			return nil, errors.ErrServerNotFound
		} else if svr, ok := s.(HallServer); !ok {
			return nil, errors.ErrServerNotFound
		} else {
			return svr.CallMessage(cancelCtx, in)
		}

	} else {
		var address string
		if len(c.address) > 0 {
			address = c.address
		} else if len(c.peerFullName) > 0 {
			if peer, err := facade.WhereIsPeer(c.peerFullName); err != nil {
				return nil, err
			} else if facade.IsEnableResolver() {
				address = peer.Url
			} else {
				address = peer.Address
			}
		} else if c.peer != nil && facade.IsEnableResolver() {
			address = c.peer.Url
		} else if c.peer != nil {
			address = c.peer.Address
		} else if len(c.serviceName) > 0 {
			if peers, err := facade.WhereIsServiceName(c.serviceName); err != nil {
				return nil, err
			} else if len(peers) < 1 {
				return nil, errors.ErrPeerNotFound
			} else if facade.IsEnableResolver() {
				address = peers[0].Url
			} else {
				address = peers[0].Address
			}
		} else if len(c.userId) > 0 {
			if peer, err := facade.WhereIsUser(c.userId); err != nil {
				return nil, err
			} else if facade.IsEnableResolver() {
				address = peer.Url
			} else {
				address = peer.Address
			}
		}
		if len(address) <= 0 {
			return nil, errors.ErrPeerNotFound
		}
		client, err := c.client.getClient(address)
		if err != nil {
			return nil, err
		}
		defer c.client.putClient(address, client)
		if c.headers.Len() > 0 {
			ctx = metadata.NewOutgoingContext(ctx, c.headers)
		}
		out, err := client.CallMessage(ctx, in, opts...)
		if err != nil {
			return nil, err
		}
		return out, nil
	}

}
func (c *hallClientsUnicast) UserInstead(ctx context.Context, in *UserInsteadRequest, opts ...grpc.CallOption) (*UserInsteadResponse, error) {
	if c.local {
		cancelCtx, cancelFunc := context.WithTimeout(ctx, time.Second*time.Duration(c.timeout))
		defer cancelFunc()
		if c.headers.Len() > 0 {
			cancelCtx = metadata.NewOutgoingContext(cancelCtx, c.headers)
		}
		if s, ok := facade.WhereIsServer(c.client.serviceName); !ok {
			return nil, errors.ErrServerNotFound
		} else if svr, ok := s.(HallServer); !ok {
			return nil, errors.ErrServerNotFound
		} else {
			return svr.UserInstead(cancelCtx, in)
		}

	} else {
		var address string
		if len(c.address) > 0 {
			address = c.address
		} else if len(c.peerFullName) > 0 {
			if peer, err := facade.WhereIsPeer(c.peerFullName); err != nil {
				return nil, err
			} else if facade.IsEnableResolver() {
				address = peer.Url
			} else {
				address = peer.Address
			}
		} else if c.peer != nil && facade.IsEnableResolver() {
			address = c.peer.Url
		} else if c.peer != nil {
			address = c.peer.Address
		} else if len(c.serviceName) > 0 {
			if peers, err := facade.WhereIsServiceName(c.serviceName); err != nil {
				return nil, err
			} else if len(peers) < 1 {
				return nil, errors.ErrPeerNotFound
			} else if facade.IsEnableResolver() {
				address = peers[0].Url
			} else {
				address = peers[0].Address
			}
		} else if len(c.userId) > 0 {
			if peer, err := facade.WhereIsUser(c.userId); err != nil {
				return nil, err
			} else if facade.IsEnableResolver() {
				address = peer.Url
			} else {
				address = peer.Address
			}
		}
		if len(address) <= 0 {
			return nil, errors.ErrPeerNotFound
		}
		client, err := c.client.getClient(address)
		if err != nil {
			return nil, err
		}
		defer c.client.putClient(address, client)
		if c.headers.Len() > 0 {
			ctx = metadata.NewOutgoingContext(ctx, c.headers)
		}
		out, err := client.UserInstead(ctx, in, opts...)
		if err != nil {
			return nil, err
		}
		return out, nil
	}

}
func (c *hallClientsUnicast) Kick(ctx context.Context, in *KickRequest, opts ...grpc.CallOption) (*KickResponse, error) {
	if c.local {
		cancelCtx, cancelFunc := context.WithTimeout(ctx, time.Second*time.Duration(c.timeout))
		defer cancelFunc()
		if c.headers.Len() > 0 {
			cancelCtx = metadata.NewOutgoingContext(cancelCtx, c.headers)
		}
		if s, ok := facade.WhereIsServer(c.client.serviceName); !ok {
			return nil, errors.ErrServerNotFound
		} else if svr, ok := s.(HallServer); !ok {
			return nil, errors.ErrServerNotFound
		} else {
			return svr.Kick(cancelCtx, in)
		}

	} else {
		var address string
		if len(c.address) > 0 {
			address = c.address
		} else if len(c.peerFullName) > 0 {
			if peer, err := facade.WhereIsPeer(c.peerFullName); err != nil {
				return nil, err
			} else if facade.IsEnableResolver() {
				address = peer.Url
			} else {
				address = peer.Address
			}
		} else if c.peer != nil && facade.IsEnableResolver() {
			address = c.peer.Url
		} else if c.peer != nil {
			address = c.peer.Address
		} else if len(c.serviceName) > 0 {
			if peers, err := facade.WhereIsServiceName(c.serviceName); err != nil {
				return nil, err
			} else if len(peers) < 1 {
				return nil, errors.ErrPeerNotFound
			} else if facade.IsEnableResolver() {
				address = peers[0].Url
			} else {
				address = peers[0].Address
			}
		} else if len(c.userId) > 0 {
			if peer, err := facade.WhereIsUser(c.userId); err != nil {
				return nil, err
			} else if facade.IsEnableResolver() {
				address = peer.Url
			} else {
				address = peer.Address
			}
		}
		if len(address) <= 0 {
			return nil, errors.ErrPeerNotFound
		}
		client, err := c.client.getClient(address)
		if err != nil {
			return nil, err
		}
		defer c.client.putClient(address, client)
		if c.headers.Len() > 0 {
			ctx = metadata.NewOutgoingContext(ctx, c.headers)
		}
		out, err := client.Kick(ctx, in, opts...)
		if err != nil {
			return nil, err
		}
		return out, nil
	}

}

type hallClientsMulticast struct {
	timeout     int64
	count       int
	serviceName string
	regex       string
	prefix      bool
	local       bool
	client      *hallClients
	headers     metadata.MD
}

type Hall_ClientStreamClient_MulticastResult struct {
	errors       []error
	peerCount    int
	successPeers []*gira.Peer
	errorPeers   []*gira.Peer
	responses    []Hall_ClientStreamClient
}

func (r *Hall_ClientStreamClient_MulticastResult) Error() error {
	if len(r.errors) <= 0 {
		return nil
	}
	return r.errors[0]
}
func (r *Hall_ClientStreamClient_MulticastResult) Response(index int) Hall_ClientStreamClient {
	if index < 0 || index >= len(r.responses) {
		return nil
	}
	return r.responses[index]
}
func (r *Hall_ClientStreamClient_MulticastResult) SuccessPeer(index int) *gira.Peer {
	if index < 0 || index >= len(r.successPeers) {
		return nil
	}
	return r.successPeers[index]
}
func (r *Hall_ClientStreamClient_MulticastResult) ErrorPeer(index int) *gira.Peer {
	if index < 0 || index >= len(r.errorPeers) {
		return nil
	}
	return r.errorPeers[index]
}
func (r *Hall_ClientStreamClient_MulticastResult) PeerCount() int {
	return r.peerCount
}
func (r *Hall_ClientStreamClient_MulticastResult) SuccessCount() int {
	return len(r.successPeers)
}
func (r *Hall_ClientStreamClient_MulticastResult) ErrorCount() int {
	return len(r.errorPeers)
}
func (r *Hall_ClientStreamClient_MulticastResult) Errors(index int) error {
	if index < 0 || index >= len(r.errors) {
		return nil
	}
	return r.errors[index]
}

type Hall_GateStreamClient_MulticastResult struct {
	errors       []error
	peerCount    int
	successPeers []*gira.Peer
	errorPeers   []*gira.Peer
	responses    []Hall_GateStreamClient
}

func (r *Hall_GateStreamClient_MulticastResult) Error() error {
	if len(r.errors) <= 0 {
		return nil
	}
	return r.errors[0]
}
func (r *Hall_GateStreamClient_MulticastResult) Response(index int) Hall_GateStreamClient {
	if index < 0 || index >= len(r.responses) {
		return nil
	}
	return r.responses[index]
}
func (r *Hall_GateStreamClient_MulticastResult) SuccessPeer(index int) *gira.Peer {
	if index < 0 || index >= len(r.successPeers) {
		return nil
	}
	return r.successPeers[index]
}
func (r *Hall_GateStreamClient_MulticastResult) ErrorPeer(index int) *gira.Peer {
	if index < 0 || index >= len(r.errorPeers) {
		return nil
	}
	return r.errorPeers[index]
}
func (r *Hall_GateStreamClient_MulticastResult) PeerCount() int {
	return r.peerCount
}
func (r *Hall_GateStreamClient_MulticastResult) SuccessCount() int {
	return len(r.successPeers)
}
func (r *Hall_GateStreamClient_MulticastResult) ErrorCount() int {
	return len(r.errorPeers)
}
func (r *Hall_GateStreamClient_MulticastResult) Errors(index int) error {
	if index < 0 || index >= len(r.errors) {
		return nil
	}
	return r.errors[index]
}
func (c *hallClientsMulticast) Local() HallClientsMulticast {
	c.local = true
	return c
}

func (c *hallClientsMulticast) WhereRegex(regex string) HallClientsMulticast {
	c.regex = regex
	return c
}

func (c *hallClientsMulticast) WherePrefix(prefix bool) HallClientsMulticast {
	c.prefix = prefix
	return c
}

func (c *hallClientsMulticast) ClientStream(ctx context.Context, opts ...grpc.CallOption) (*Hall_ClientStreamClient_MulticastResult, error) {
	if c.local {
		return nil, status.Errorf(codes.Unimplemented, "method ClientStream not implemented")

	} else {
		var peers []*gira.Peer
		var whereOpts []service_options.WhereOption
		// 多播
		whereOpts = append(whereOpts, service_options.WithWhereCatalogOption())
		if c.count > 0 {
			whereOpts = append(whereOpts, service_options.WithWhereMaxCountOption(c.count))
		}
		serviceName := c.serviceName
		if len(c.regex) > 0 {
			serviceName = fmt.Sprintf("%s%s", c.serviceName, c.regex)
			whereOpts = append(whereOpts, service_options.WithWhereRegexOption())
		}
		if c.prefix {
			whereOpts = append(whereOpts, service_options.WithWherePrefixOption())
		}
		peers, err := facade.WhereIsServiceName(serviceName, whereOpts...)
		if err != nil {
			return nil, err
		}
		result := &Hall_ClientStreamClient_MulticastResult{}
		result.peerCount = len(peers)
		for _, peer := range peers {
			var address string
			if facade.IsEnableResolver() {
				address = peer.Url
			} else {
				address = peer.Address
			}
			client, err := c.client.getClient(address)
			if err != nil {
				result.errors = append(result.errors, err)
				result.errorPeers = append(result.errorPeers, peer)
				continue
			}
			out, err := client.ClientStream(ctx, opts...)
			if err != nil {
				result.errors = append(result.errors, err)
				result.errorPeers = append(result.errorPeers, peer)
				c.client.putClient(address, client)
				continue
			}
			result.responses = append(result.responses, out)
			result.successPeers = append(result.successPeers, peer)
		}
		return result, nil
	}

}
func (c *hallClientsMulticast) GateStream(ctx context.Context, opts ...grpc.CallOption) (*Hall_GateStreamClient_MulticastResult, error) {
	if c.local {
		return nil, status.Errorf(codes.Unimplemented, "method GateStream not implemented")

	} else {
		var peers []*gira.Peer
		var whereOpts []service_options.WhereOption
		// 多播
		whereOpts = append(whereOpts, service_options.WithWhereCatalogOption())
		if c.count > 0 {
			whereOpts = append(whereOpts, service_options.WithWhereMaxCountOption(c.count))
		}
		serviceName := c.serviceName
		if len(c.regex) > 0 {
			serviceName = fmt.Sprintf("%s%s", c.serviceName, c.regex)
			whereOpts = append(whereOpts, service_options.WithWhereRegexOption())
		}
		if c.prefix {
			whereOpts = append(whereOpts, service_options.WithWherePrefixOption())
		}
		peers, err := facade.WhereIsServiceName(serviceName, whereOpts...)
		if err != nil {
			return nil, err
		}
		result := &Hall_GateStreamClient_MulticastResult{}
		result.peerCount = len(peers)
		for _, peer := range peers {
			var address string
			if facade.IsEnableResolver() {
				address = peer.Url
			} else {
				address = peer.Address
			}
			client, err := c.client.getClient(address)
			if err != nil {
				result.errors = append(result.errors, err)
				result.errorPeers = append(result.errorPeers, peer)
				continue
			}
			out, err := client.GateStream(ctx, opts...)
			if err != nil {
				result.errors = append(result.errors, err)
				result.errorPeers = append(result.errorPeers, peer)
				c.client.putClient(address, client)
				continue
			}
			result.responses = append(result.responses, out)
			result.successPeers = append(result.successPeers, peer)
		}
		return result, nil
	}

}
func (c *hallClientsMulticast) Info(ctx context.Context, in *InfoRequest, opts ...grpc.CallOption) (*InfoResponse_MulticastResult, error) {
	if c.local {
		if s, ok := facade.WhereIsServer(c.client.serviceName); !ok {
			return nil, errors.ErrServerNotFound
		} else if svr, ok := s.(HallServer); ok {
			result := &InfoResponse_MulticastResult{}
			cancelCtx, cancelFunc := context.WithTimeout(ctx, time.Second*time.Duration(c.timeout))
			defer cancelFunc()
			if c.headers.Len() > 0 {
				cancelCtx = metadata.NewOutgoingContext(cancelCtx, c.headers)
			}
			if resp, err := svr.Info(cancelCtx, in); err != nil {
				return nil, err
			} else {
				result.responses = append(result.responses, resp)
			}
			return result, nil
		} else {
			return nil, errors.ErrServerNotFound
		}
	} else {
		var peers []*gira.Peer
		var whereOpts []service_options.WhereOption
		// 多播
		whereOpts = append(whereOpts, service_options.WithWhereCatalogOption())
		if c.count > 0 {
			whereOpts = append(whereOpts, service_options.WithWhereMaxCountOption(c.count))
		}
		serviceName := c.serviceName
		if len(c.regex) > 0 {
			serviceName = fmt.Sprintf("%s%s", c.serviceName, c.regex)
			whereOpts = append(whereOpts, service_options.WithWhereRegexOption())
		}
		if c.prefix {
			whereOpts = append(whereOpts, service_options.WithWherePrefixOption())
		}
		peers, err := facade.WhereIsServiceName(serviceName, whereOpts...)
		if err != nil {
			return nil, err
		}
		result := &InfoResponse_MulticastResult{}
		result.peerCount = len(peers)
		for _, peer := range peers {
			var address string
			if facade.IsEnableResolver() {
				address = peer.Url
			} else {
				address = peer.Address
			}
			client, err := c.client.getClient(address)
			if err != nil {
				result.errors = append(result.errors, err)
				result.errorPeers = append(result.errorPeers, peer)
				continue
			}
			out, err := client.Info(ctx, in, opts...)
			if err != nil {
				result.errors = append(result.errors, err)
				result.errorPeers = append(result.errorPeers, peer)
				c.client.putClient(address, client)
				continue
			}
			c.client.putClient(address, client)
			result.responses = append(result.responses, out)
			result.successPeers = append(result.successPeers, peer)
		}
		return result, nil
	}

}
func (c *hallClientsMulticast) HealthCheck(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse_MulticastResult, error) {
	if c.local {
		if s, ok := facade.WhereIsServer(c.client.serviceName); !ok {
			return nil, errors.ErrServerNotFound
		} else if svr, ok := s.(HallServer); ok {
			result := &HealthCheckResponse_MulticastResult{}
			cancelCtx, cancelFunc := context.WithTimeout(ctx, time.Second*time.Duration(c.timeout))
			defer cancelFunc()
			if c.headers.Len() > 0 {
				cancelCtx = metadata.NewOutgoingContext(cancelCtx, c.headers)
			}
			if resp, err := svr.HealthCheck(cancelCtx, in); err != nil {
				return nil, err
			} else {
				result.responses = append(result.responses, resp)
			}
			return result, nil
		} else {
			return nil, errors.ErrServerNotFound
		}
	} else {
		var peers []*gira.Peer
		var whereOpts []service_options.WhereOption
		// 多播
		whereOpts = append(whereOpts, service_options.WithWhereCatalogOption())
		if c.count > 0 {
			whereOpts = append(whereOpts, service_options.WithWhereMaxCountOption(c.count))
		}
		serviceName := c.serviceName
		if len(c.regex) > 0 {
			serviceName = fmt.Sprintf("%s%s", c.serviceName, c.regex)
			whereOpts = append(whereOpts, service_options.WithWhereRegexOption())
		}
		if c.prefix {
			whereOpts = append(whereOpts, service_options.WithWherePrefixOption())
		}
		peers, err := facade.WhereIsServiceName(serviceName, whereOpts...)
		if err != nil {
			return nil, err
		}
		result := &HealthCheckResponse_MulticastResult{}
		result.peerCount = len(peers)
		for _, peer := range peers {
			var address string
			if facade.IsEnableResolver() {
				address = peer.Url
			} else {
				address = peer.Address
			}
			client, err := c.client.getClient(address)
			if err != nil {
				result.errors = append(result.errors, err)
				result.errorPeers = append(result.errorPeers, peer)
				continue
			}
			out, err := client.HealthCheck(ctx, in, opts...)
			if err != nil {
				result.errors = append(result.errors, err)
				result.errorPeers = append(result.errorPeers, peer)
				c.client.putClient(address, client)
				continue
			}
			c.client.putClient(address, client)
			result.responses = append(result.responses, out)
			result.successPeers = append(result.successPeers, peer)
		}
		return result, nil
	}

}
func (c *hallClientsMulticast) MustPush(ctx context.Context, in *MustPushRequest, opts ...grpc.CallOption) (*MustPushResponse_MulticastResult, error) {
	if c.local {
		if s, ok := facade.WhereIsServer(c.client.serviceName); !ok {
			return nil, errors.ErrServerNotFound
		} else if svr, ok := s.(HallServer); ok {
			result := &MustPushResponse_MulticastResult{}
			cancelCtx, cancelFunc := context.WithTimeout(ctx, time.Second*time.Duration(c.timeout))
			defer cancelFunc()
			if c.headers.Len() > 0 {
				cancelCtx = metadata.NewOutgoingContext(cancelCtx, c.headers)
			}
			if resp, err := svr.MustPush(cancelCtx, in); err != nil {
				return nil, err
			} else {
				result.responses = append(result.responses, resp)
			}
			return result, nil
		} else {
			return nil, errors.ErrServerNotFound
		}
	} else {
		var peers []*gira.Peer
		var whereOpts []service_options.WhereOption
		// 多播
		whereOpts = append(whereOpts, service_options.WithWhereCatalogOption())
		if c.count > 0 {
			whereOpts = append(whereOpts, service_options.WithWhereMaxCountOption(c.count))
		}
		serviceName := c.serviceName
		if len(c.regex) > 0 {
			serviceName = fmt.Sprintf("%s%s", c.serviceName, c.regex)
			whereOpts = append(whereOpts, service_options.WithWhereRegexOption())
		}
		if c.prefix {
			whereOpts = append(whereOpts, service_options.WithWherePrefixOption())
		}
		peers, err := facade.WhereIsServiceName(serviceName, whereOpts...)
		if err != nil {
			return nil, err
		}
		result := &MustPushResponse_MulticastResult{}
		result.peerCount = len(peers)
		for _, peer := range peers {
			var address string
			if facade.IsEnableResolver() {
				address = peer.Url
			} else {
				address = peer.Address
			}
			client, err := c.client.getClient(address)
			if err != nil {
				result.errors = append(result.errors, err)
				result.errorPeers = append(result.errorPeers, peer)
				continue
			}
			out, err := client.MustPush(ctx, in, opts...)
			if err != nil {
				result.errors = append(result.errors, err)
				result.errorPeers = append(result.errorPeers, peer)
				c.client.putClient(address, client)
				continue
			}
			c.client.putClient(address, client)
			result.responses = append(result.responses, out)
			result.successPeers = append(result.successPeers, peer)
		}
		return result, nil
	}

}
func (c *hallClientsMulticast) SendMessage(ctx context.Context, in *SendMessageRequest, opts ...grpc.CallOption) (*SendMessageResponse_MulticastResult, error) {
	if c.local {
		if s, ok := facade.WhereIsServer(c.client.serviceName); !ok {
			return nil, errors.ErrServerNotFound
		} else if svr, ok := s.(HallServer); ok {
			result := &SendMessageResponse_MulticastResult{}
			cancelCtx, cancelFunc := context.WithTimeout(ctx, time.Second*time.Duration(c.timeout))
			defer cancelFunc()
			if c.headers.Len() > 0 {
				cancelCtx = metadata.NewOutgoingContext(cancelCtx, c.headers)
			}
			if resp, err := svr.SendMessage(cancelCtx, in); err != nil {
				return nil, err
			} else {
				result.responses = append(result.responses, resp)
			}
			return result, nil
		} else {
			return nil, errors.ErrServerNotFound
		}
	} else {
		var peers []*gira.Peer
		var whereOpts []service_options.WhereOption
		// 多播
		whereOpts = append(whereOpts, service_options.WithWhereCatalogOption())
		if c.count > 0 {
			whereOpts = append(whereOpts, service_options.WithWhereMaxCountOption(c.count))
		}
		serviceName := c.serviceName
		if len(c.regex) > 0 {
			serviceName = fmt.Sprintf("%s%s", c.serviceName, c.regex)
			whereOpts = append(whereOpts, service_options.WithWhereRegexOption())
		}
		if c.prefix {
			whereOpts = append(whereOpts, service_options.WithWherePrefixOption())
		}
		peers, err := facade.WhereIsServiceName(serviceName, whereOpts...)
		if err != nil {
			return nil, err
		}
		result := &SendMessageResponse_MulticastResult{}
		result.peerCount = len(peers)
		for _, peer := range peers {
			var address string
			if facade.IsEnableResolver() {
				address = peer.Url
			} else {
				address = peer.Address
			}
			client, err := c.client.getClient(address)
			if err != nil {
				result.errors = append(result.errors, err)
				result.errorPeers = append(result.errorPeers, peer)
				continue
			}
			out, err := client.SendMessage(ctx, in, opts...)
			if err != nil {
				result.errors = append(result.errors, err)
				result.errorPeers = append(result.errorPeers, peer)
				c.client.putClient(address, client)
				continue
			}
			c.client.putClient(address, client)
			result.responses = append(result.responses, out)
			result.successPeers = append(result.successPeers, peer)
		}
		return result, nil
	}

}
func (c *hallClientsMulticast) CallMessage(ctx context.Context, in *CallMessageRequest, opts ...grpc.CallOption) (*CallMessageResponse_MulticastResult, error) {
	if c.local {
		if s, ok := facade.WhereIsServer(c.client.serviceName); !ok {
			return nil, errors.ErrServerNotFound
		} else if svr, ok := s.(HallServer); ok {
			result := &CallMessageResponse_MulticastResult{}
			cancelCtx, cancelFunc := context.WithTimeout(ctx, time.Second*time.Duration(c.timeout))
			defer cancelFunc()
			if c.headers.Len() > 0 {
				cancelCtx = metadata.NewOutgoingContext(cancelCtx, c.headers)
			}
			if resp, err := svr.CallMessage(cancelCtx, in); err != nil {
				return nil, err
			} else {
				result.responses = append(result.responses, resp)
			}
			return result, nil
		} else {
			return nil, errors.ErrServerNotFound
		}
	} else {
		var peers []*gira.Peer
		var whereOpts []service_options.WhereOption
		// 多播
		whereOpts = append(whereOpts, service_options.WithWhereCatalogOption())
		if c.count > 0 {
			whereOpts = append(whereOpts, service_options.WithWhereMaxCountOption(c.count))
		}
		serviceName := c.serviceName
		if len(c.regex) > 0 {
			serviceName = fmt.Sprintf("%s%s", c.serviceName, c.regex)
			whereOpts = append(whereOpts, service_options.WithWhereRegexOption())
		}
		if c.prefix {
			whereOpts = append(whereOpts, service_options.WithWherePrefixOption())
		}
		peers, err := facade.WhereIsServiceName(serviceName, whereOpts...)
		if err != nil {
			return nil, err
		}
		result := &CallMessageResponse_MulticastResult{}
		result.peerCount = len(peers)
		for _, peer := range peers {
			var address string
			if facade.IsEnableResolver() {
				address = peer.Url
			} else {
				address = peer.Address
			}
			client, err := c.client.getClient(address)
			if err != nil {
				result.errors = append(result.errors, err)
				result.errorPeers = append(result.errorPeers, peer)
				continue
			}
			out, err := client.CallMessage(ctx, in, opts...)
			if err != nil {
				result.errors = append(result.errors, err)
				result.errorPeers = append(result.errorPeers, peer)
				c.client.putClient(address, client)
				continue
			}
			c.client.putClient(address, client)
			result.responses = append(result.responses, out)
			result.successPeers = append(result.successPeers, peer)
		}
		return result, nil
	}

}
func (c *hallClientsMulticast) UserInstead(ctx context.Context, in *UserInsteadRequest, opts ...grpc.CallOption) (*UserInsteadResponse_MulticastResult, error) {
	if c.local {
		if s, ok := facade.WhereIsServer(c.client.serviceName); !ok {
			return nil, errors.ErrServerNotFound
		} else if svr, ok := s.(HallServer); ok {
			result := &UserInsteadResponse_MulticastResult{}
			cancelCtx, cancelFunc := context.WithTimeout(ctx, time.Second*time.Duration(c.timeout))
			defer cancelFunc()
			if c.headers.Len() > 0 {
				cancelCtx = metadata.NewOutgoingContext(cancelCtx, c.headers)
			}
			if resp, err := svr.UserInstead(cancelCtx, in); err != nil {
				return nil, err
			} else {
				result.responses = append(result.responses, resp)
			}
			return result, nil
		} else {
			return nil, errors.ErrServerNotFound
		}
	} else {
		var peers []*gira.Peer
		var whereOpts []service_options.WhereOption
		// 多播
		whereOpts = append(whereOpts, service_options.WithWhereCatalogOption())
		if c.count > 0 {
			whereOpts = append(whereOpts, service_options.WithWhereMaxCountOption(c.count))
		}
		serviceName := c.serviceName
		if len(c.regex) > 0 {
			serviceName = fmt.Sprintf("%s%s", c.serviceName, c.regex)
			whereOpts = append(whereOpts, service_options.WithWhereRegexOption())
		}
		if c.prefix {
			whereOpts = append(whereOpts, service_options.WithWherePrefixOption())
		}
		peers, err := facade.WhereIsServiceName(serviceName, whereOpts...)
		if err != nil {
			return nil, err
		}
		result := &UserInsteadResponse_MulticastResult{}
		result.peerCount = len(peers)
		for _, peer := range peers {
			var address string
			if facade.IsEnableResolver() {
				address = peer.Url
			} else {
				address = peer.Address
			}
			client, err := c.client.getClient(address)
			if err != nil {
				result.errors = append(result.errors, err)
				result.errorPeers = append(result.errorPeers, peer)
				continue
			}
			out, err := client.UserInstead(ctx, in, opts...)
			if err != nil {
				result.errors = append(result.errors, err)
				result.errorPeers = append(result.errorPeers, peer)
				c.client.putClient(address, client)
				continue
			}
			c.client.putClient(address, client)
			result.responses = append(result.responses, out)
			result.successPeers = append(result.successPeers, peer)
		}
		return result, nil
	}

}
func (c *hallClientsMulticast) Kick(ctx context.Context, in *KickRequest, opts ...grpc.CallOption) (*KickResponse_MulticastResult, error) {
	if c.local {
		if s, ok := facade.WhereIsServer(c.client.serviceName); !ok {
			return nil, errors.ErrServerNotFound
		} else if svr, ok := s.(HallServer); ok {
			result := &KickResponse_MulticastResult{}
			cancelCtx, cancelFunc := context.WithTimeout(ctx, time.Second*time.Duration(c.timeout))
			defer cancelFunc()
			if c.headers.Len() > 0 {
				cancelCtx = metadata.NewOutgoingContext(cancelCtx, c.headers)
			}
			if resp, err := svr.Kick(cancelCtx, in); err != nil {
				return nil, err
			} else {
				result.responses = append(result.responses, resp)
			}
			return result, nil
		} else {
			return nil, errors.ErrServerNotFound
		}
	} else {
		var peers []*gira.Peer
		var whereOpts []service_options.WhereOption
		// 多播
		whereOpts = append(whereOpts, service_options.WithWhereCatalogOption())
		if c.count > 0 {
			whereOpts = append(whereOpts, service_options.WithWhereMaxCountOption(c.count))
		}
		serviceName := c.serviceName
		if len(c.regex) > 0 {
			serviceName = fmt.Sprintf("%s%s", c.serviceName, c.regex)
			whereOpts = append(whereOpts, service_options.WithWhereRegexOption())
		}
		if c.prefix {
			whereOpts = append(whereOpts, service_options.WithWherePrefixOption())
		}
		peers, err := facade.WhereIsServiceName(serviceName, whereOpts...)
		if err != nil {
			return nil, err
		}
		result := &KickResponse_MulticastResult{}
		result.peerCount = len(peers)
		for _, peer := range peers {
			var address string
			if facade.IsEnableResolver() {
				address = peer.Url
			} else {
				address = peer.Address
			}
			client, err := c.client.getClient(address)
			if err != nil {
				result.errors = append(result.errors, err)
				result.errorPeers = append(result.errorPeers, peer)
				continue
			}
			out, err := client.Kick(ctx, in, opts...)
			if err != nil {
				result.errors = append(result.errors, err)
				result.errorPeers = append(result.errorPeers, peer)
				c.client.putClient(address, client)
				continue
			}
			c.client.putClient(address, client)
			result.responses = append(result.responses, out)
			result.successPeers = append(result.successPeers, peer)
		}
		return result, nil
	}

}
