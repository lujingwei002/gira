package gen_resources

/// 参考 https://www.cnblogs.com/f-ck-need-u/p/10053124.html

import (
	"crypto/md5"
	"encoding/hex"
	"fmt"
	"io/ioutil"
	"os"
	"path"
	"path/filepath"
	"sort"
	"strings"
	"text/template"

	"github.com/lujingwei002/gira"
	"github.com/lujingwei002/gira/log"

	"github.com/lujingwei002/gira/proj"
	excelize "github.com/xuri/excelize/v2"
	yaml "gopkg.in/yaml.v3"
)

var cli_code = `
// Code generated by github.com/lujingwei002/gira. DO NOT EDIT.
// Code generated by github.com/lujingwei002/gira. DO NOT EDIT.
// Code generated by github.com/lujingwei002/gira. DO NOT EDIT.

package main

import (
	"context"
	"log"
	"os"
	"github.com/urfave/cli/v2"
	"<<.Module>>/gen/resource"
)

func main() {
	app := &cli.App{
		Name: "gira-resource",
		Authors: []*cli.Author{{
			Name:  "lujingwei",
			Email: "lujingwei@xx.org",
		}},
		Description: "gira-cli",
		Flags:       []cli.Flag{},
		Commands: []*cli.Command{
			{
				Name:   "compress",
				Usage:  "compress yaml to binary",
				Action: compressAction,
			},
			{
				Name:      "push",
				Usage:     "push to database",
				Action:    pushAction,
				ArgsUsage: "[目标地址]",
			},
		},
	}
	if err := app.Run(os.Args); err != nil {
		log.Println(err)
	}
}

func compressAction(args *cli.Context) error {
	if err := resource.Compress("resource"); err != nil {
		return err
	} else {
		log.Println("success")
		return nil
	}
}

func pushAction(args *cli.Context) error {
	if args.NArg() <= 0 {
		cli.ShowAppHelp(args)
		return nil
	}
	return resource.Push(context.Background(), args.Args().Get(0), "resource")
}
`

var code = `
// Code generated by github.com/lujingwei002/gira. DO NOT EDIT.
// Code generated by github.com/lujingwei002/gira. DO NOT EDIT.
// Code generated by github.com/lujingwei002/gira. DO NOT EDIT.

package resource
import (
	"github.com/lujingwei002/gira"
	yaml "gopkg.in/yaml.v3"
	"io/ioutil"
	"path/filepath"
	"encoding/gob"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
	"go.mongodb.org/mongo-driver/mongo/readpref"
	"go.mongodb.org/mongo-driver/bson"
	"time"
	"github.com/lujingwei002/gira/log"
	"os"
	"fmt"
	"context"
	"net/url"
	"strings"
)

// mongodb://root:123456@192.168.1.200:3331/resourcedb
func Push(ctx context.Context, uri string, dir string) error {
	u, err := url.Parse(uri)
    if err != nil {
        log.Infow("parsing mongodb uri fail", "error", err)
        return err
    }
    path := strings.TrimPrefix(u.Path, "/")
	uri = strings.Replace(uri, u.Path, "", 1)
	log.Info(uri, path)

	clientOpts := options.Client().
		ApplyURI(uri)
	ctx1, cancelFunc1 := context.WithTimeout(ctx, 3*time.Second)
	defer cancelFunc1()
	client, err := mongo.Connect(ctx1, clientOpts)
	if err != nil {
		log.Infow("connect accountdb fail", "error", err)
		return err
	}
	ctx2, cancelFunc2 := context.WithTimeout(ctx, 3*time.Second)
	defer cancelFunc2()
	if err = client.Ping(ctx2, readpref.Primary()); err != nil {
		log.Info("connect accountdb fail", "error", err)
		return err
	}
	log.Info("connect accountdb success")
	database := client.Database(path)

	<<- range .BundleArr>>
	<<- if  eq .BundleType "db">>
	<<.CapBundleStructName>> := &<<.BundleStructName>>{}
	if err := <<.CapBundleStructName>>.SaveToDb(ctx, database, dir); err != nil {
        return err
	}
	<<- end>>
	<<- end>>
	return nil
}

func Compress(dir string) error {
<<range .BundleArr>>
	// <<.BundleStructName>>
	<<.CapBundleStructName>> := &<<.BundleStructName>>{}
	if err := <<.CapBundleStructName>>.LoadFromYaml(dir); err != nil {
        return err
	}
	if err := <<.CapBundleStructName>>.SaveToBin(dir); err != nil {
        return err
	}
<<end>>
	return nil
}


<<range .LoaderArr>>
type <<.HandlerStructName>> interface {
	<<- range .BundleArr>>
		<<- range .DescriptorArr>>
	Convert<<.StructName>>(arr <<.WrapStructName>>) error
	Load<<.StructName>>(reload bool) error
		<<- end>>
	<<- end>>
}
<<end>>


<<range .LoaderArr>>
type <<.LoaderStructName>> struct {
	<<- range .BundleArr>>
	<<.BundleStructName>>
	<<- end>>
}

func (self *<<.LoaderStructName>>) LoadFromYaml(dir string) error {
	<<- range .BundleArr>>
	if err := self.<<.BundleStructName>>.LoadFromYaml(dir); err != nil {
		return err
	}
	<<- end>>
	return nil
}

func (self *<<.LoaderStructName>>) LoadFromBin(dir string) error {
	<<- range .BundleArr>>
	if err := self.<<.BundleStructName>>.LoadFromBin(dir); err != nil {
		return err
	}
	<<- end>>
	return nil
}

func (self *<<.LoaderStructName>>) LoadFromDb(ctx context.Context, database *mongo.Database) error {
	<<- range .BundleArr>>
	if err := self.<<.BundleStructName>>.LoadFromDb(ctx, database); err != nil {
		return err
	}
	<<- end>>
	return nil
}

func (self *<<.LoaderStructName>>) Load(ctx context.Context, database *mongo.Database, dir string) error {
	<<- range .BundleArr>>
	<<- if eq .BundleType "db">>
	if err := self.<<.BundleStructName>>.LoadFromDb(ctx, database); err != nil {
		return err
	}
	<<- end>>
	<<- if eq .BundleType "raw">>
	if err := self.<<.BundleStructName>>.LoadFromYaml(dir); err != nil {
		return err
	}
	<<- end>>
	<<- if eq .BundleType "bin">>
	if err := self.<<.BundleStructName>>.LoadFromBin(dir); err != nil {
		return err
	}
	<<- end>>
	<<- end>>
	return nil
}

func (self *<<.LoaderStructName>>) Convert(handler gira.ResourceHandler) error {
	handler.OnResourcePreLoad()
	h := handler.(<<.HandlerStructName>>)
	<<- range .BundleArr>>
		<<- $bundleStructName := .BundleStructName>>
		<<- range .DescriptorArr>>
	if err := h.Convert<<.StructName>>(self.<<$bundleStructName>>.<<.WrapStructName>>); err != nil {
		return err
	}
		<<- end>>
	<<- end>>
	handler.OnResourcePostLoad()
	return nil
}
<<end>>

<<range .BundleArr>>
type <<.BundleStructName>> struct {
<<- range .DescriptorArr>>
	<<.WrapStructName>> <<.WrapStructName>>
<<- end>>
}

func (self* <<.BundleStructName>>) Clear() {
	<<- range .DescriptorArr>>
		<<- if .IsDeriveObject>>
		<<- else>>
		self.<<.WrapStructName>> = make(<<.GoTypeName>>, 0)
		<<- end>>
	<<- end>>
}
func (self* <<.BundleStructName>>) LoadFromYaml(dir string) error {
	self.Clear()
	<<- range .DescriptorArr>>
	var <<.CapStructName>>filePath = filepath.Join(dir, "<<.YamlFilePath>>")
	if err := self.<<.WrapStructName>>.LoadFromYaml(<<.CapStructName>>filePath); err != nil {
		return err
	}
	<<end>>
	return nil
}

func (self* <<.BundleStructName>>) LoadFromDb(ctx context.Context, database *mongo.Database) error {
	self.Clear()
	<<- range .DescriptorArr>>
	if err := self.<<.WrapStructName>>.LoadFromDb(ctx, database); err != nil {
		return err
	}
	<<- end>>
	return nil
}

func (self* <<.BundleStructName>>) LoadFromBin(dir string) error {
	var filePath = filepath.Join(dir, "<<.BundleName>>.bin")
	f, err := os.OpenFile(filePath, os.O_RDONLY, 0666)
	if err != nil {
		return err
	}
	defer f.Close()
	encoder := gob.NewDecoder(f)
	if err := encoder.Decode(self); err != nil {
		return err
	}
	return nil
}

func (self *<<.BundleStructName>>) SaveToBin(dir string) error {
	var filePath = filepath.Join(dir, "<<.BundleName>>.bin")
	f, err := os.OpenFile(filePath, os.O_WRONLY|os.O_CREATE, 0666)
	if err != nil {
		return err
	}
	defer f.Close()
	encoder := gob.NewEncoder(f)
	if err := encoder.Encode(self); err != nil {
		return err
	}
	return nil
}

func (self *<<.BundleStructName>>) SaveToDb(ctx context.Context, database *mongo.Database, dir string) error {
	<<- range .DescriptorArr>>
	var <<.CapStructName>>filePath = filepath.Join(dir, "<<.YamlFilePath>>")
	var <<.ArrTypeName>> <<.ArrTypeName>>
	if err := <<.ArrTypeName>>.LoadFromYaml(<<.CapStructName>>filePath); err != nil {
		return err
	}
	<<- end>>
	<<- range .DescriptorArr>>

	if coll := database.Collection("<<.TableName>>"); coll == nil {
		return fmt.Errorf("collection <<.TableName>> not found")
	} else {
		coll.Drop(ctx)
		models := make([]mongo.WriteModel, 0)
		for _, v := range <<.ArrTypeName>> {
			models = append(models, mongo.NewInsertOneModel().SetDocument(v))
		}
		if _, err := coll.BulkWrite(ctx, models); err != nil {
			log.Info("push <<.TableName>> fail", err)
			return err
		} else {
			log.Infof("push <<.TableName>>(%d) success", len(<<.ArrTypeName>>))
		}
	}

	<<end>>
	return nil
}
<<end>>

<<- range .DescriptorArr>>
type <<.StructName>> struct {
	<<- range .FieldArr>>
	<<.CapFieldName>> <<.GoTypeName>> <<quote>>bson:"<<.FieldName>>" json:"<<.FieldName>>" yaml:"<<.FieldName>>"<<quote>>
	<<- end>>
}

type <<.ArrTypeName>> []*<<.StructName>>

func (self *<<.ArrTypeName>>) LoadFromYaml(filePath string) error {
	data, err := ioutil.ReadFile(filePath)
	if err != nil {
		return err
	}
	if err := yaml.Unmarshal(data, self); err != nil {
		return err
	}
	return nil
}

func (self *<<.ArrTypeName>>) LoadFromDb(ctx context.Context, database *mongo.Database) error {
	coll := database.Collection("<<.TableName>>")
	if cursor, err := coll.Find(ctx, bson.D{}); err != nil {
		return err
	} else {
		defer cursor.Close(ctx)
		if err := cursor.All(ctx, self); err != nil {
			return err
		}
	}
	return nil
}

/// 字典类型的配置,转换成字典格式
<<- if .IsDeriveMap>>
type <<.MapTypeName>> <<.GoMapTypeName>>
func (self *<<.WrapStructName>>) LoadFromYaml(filePath string) error {
	var arr <<.ArrTypeName>>
	if err := arr.LoadFromYaml(filePath); err != nil {
		return err
	}
	return self.Make(arr)
}

func (self *<<.WrapStructName>>) LoadFromDb(ctx context.Context, database *mongo.Database) error {
	var arr <<.ArrTypeName>>
	if err := arr.LoadFromDb(ctx, database); err != nil {
		return err
	}
	return self.Make(arr)
}

func (self *<<.WrapStructName>>) Make(arr <<.ArrTypeName>>) error {
	if err := gira.Make<<len .KeyArr>>Key_<<join .KeyGoTypeNameArr "_">>(arr, *self<<- range $k, $v := .KeyArr>>, "<<camelString $v>>"<<- end>>); err != nil {
		return err
	}
	return nil
}
<<- end>>

/// 对像类型的配置,转换成对象格式
<<- if .IsDeriveObject>>
type <<.GoObjectTypeName>> struct {
	<<$descriptor := .>>
	<<- range .ExcelData.ValueArr>>
	<<- $v := index . $descriptor.ObjectKeyIndex>>
	<< camelString $v>> *<<$descriptor.StructName>>
	<<- end>>
}

func (self *<<.WrapStructName>>) LoadFromYaml(filePath string) error {
	var arr <<.ArrTypeName>>
	if err := arr.LoadFromYaml(filePath); err != nil {
		return err
	}
	return self.Make(arr)
	return nil
}


func (self *<<.WrapStructName>>) LoadFromDb(ctx context.Context, database *mongo.Database) error {
	var arr <<.ArrTypeName>>
	if err := arr.LoadFromDb(ctx, database); err != nil {
		return err
	}
	return self.Make(arr)
}


func (self *<<.WrapStructName>>) Make(arr <<.ArrTypeName>>) error {
	dict := make(<<.GoMapTypeName>> ,0)
	if err := gira.Make<<len .KeyArr>>Key_<<join .KeyGoTypeNameArr "_">>(arr, dict<<- range $k, $v := .KeyArr>>, "<<camelString $v>>"<<- end>>); err != nil {
		return err
	}
	var ok bool
	<<- range .ExcelData.ValueArr>>
		<<- $v := index . $descriptor.ObjectKeyIndex>>
	if self.<<- camelString $v>>, ok = dict["<<$v>>"]; !ok {
		return fmt.Errorf("<<$descriptor.StructName>> <<$v>> key not found")
	}
	<<- end>>
	return nil
}
	<<- end>>


<<- end>>

`

func QuoteChar() interface{} {
	return "`"
}

// 字段类型
type field_type int

const (
	field_type_int field_type = iota
	field_type_int32
	field_type_int64
	field_type_string
	field_type_json
	field_type_bool
)

type descriptor_type int

const (
	descriptor_type_array = iota
	descriptor_type_map
	descriptor_type_object
)

var type_name_dict = map[string]field_type{
	"int":    field_type_int,
	"int64":  field_type_int64,
	"int32":  field_type_int32,
	"string": field_type_string,
	"json":   field_type_json,
	"bool":   field_type_bool,
}

var go_type_name_dict = map[field_type]string{
	field_type_int:    "int64",
	field_type_int64:  "int64",
	field_type_int32:  "int32",
	field_type_string: "string",
	field_type_json:   "interface{}",
	field_type_bool:   "bool",
}

var descriptor_type_name_dict = map[string]descriptor_type{
	"map":    descriptor_type_map,
	"object": descriptor_type_object,
	"array":  descriptor_type_array,
}

// 字段结构
type Field struct {
	tag          int
	FieldName    string     // 字段名
	CapFieldName string     // 字段名
	Type         field_type // 字段类型
	GoTypeName   string
}

type ExcelData struct {
	FieldDict map[string]*Field // 字段信息
	FieldArr  []*Field          // 字段信息
	ValueArr  [][]interface{}   // 字段值
}

type Descriptor struct {
	Name             string
	StructName       string
	TableName        string
	CapStructName    string
	WrapStructName   string
	GoTypeName       string
	YamlFilePath     string
	FieldArr         []*Field          // 字段信息
	FieldDict        map[string]*Field // 字段信息
	ArrTypeName      string            // ErrorCodeArr
	KeyArr           []string
	MapTypeName      string // ErrorCodeMap
	FilePath         string
	GoMapTypeName    string // map[int] *ErrorCode
	ExcelData        *ExcelData
	ObjectKeyIndex   int
	Type             descriptor_type
	realArrTypeName  string // []*ErrorCode
	GoObjectTypeName string
	KeyGoTypeNameArr []string
}

type SortDescriptorByName []*Descriptor

func (self SortDescriptorByName) Len() int           { return len(self) }
func (self SortDescriptorByName) Swap(i, j int)      { self[i], self[j] = self[j], self[i] }
func (self SortDescriptorByName) Less(i, j int) bool { return self[i].StructName < self[j].StructName }

func (self *Descriptor) IsDeriveMap() bool {
	return self.Type == descriptor_type_map
}

func (self *Descriptor) IsDeriveObject() bool {
	return self.Type == descriptor_type_object
}

type Bundle struct {
	BundleType          string // file binary db
	BundleName          string
	BundleStructName    string
	CapBundleStructName string
	descriptorNameArr   []string
	DescriptorArr       []*Descriptor
}

type SortBundleByName []*Bundle

func (self SortBundleByName) Len() int           { return len(self) }
func (self SortBundleByName) Swap(i, j int)      { self[i], self[j] = self[j], self[i] }
func (self SortBundleByName) Less(i, j int) bool { return self[i].BundleName < self[j].BundleName }

type Loader struct {
	LoaderStructName  string
	Name              string
	HandlerStructName string
	bundleNameArr     []string
	BundleArr         []*Bundle
}

type SortLoaderByName []*Loader

func (self SortLoaderByName) Len() int           { return len(self) }
func (self SortLoaderByName) Swap(i, j int)      { self[i], self[j] = self[j], self[i] }
func (self SortLoaderByName) Less(i, j int) bool { return self[i].Name < self[j].Name }

type ResourceFile struct {
	DescriptorDict map[string]*Descriptor
	DescriptorArr  []*Descriptor
	BundleDict     map[string]*Bundle
	BundleArr      []*Bundle
	LoaderArr      []*Loader
}

// 生成协议的状态
type GenState struct {
	Module        string
	ResourceFile  ResourceFile
	ExcelDataDict map[string]*ExcelData
}

func capUpperString(s string) string {
	return strings.ToUpper(s[0:1]) + s[1:]
}

func capLowerString(s string) string {
	return strings.ToLower(s[0:1]) + s[1:]
}

func camelString(s string) string {
	data := make([]byte, 0, len(s))
	j := false
	k := false
	num := len(s) - 1
	for i := 0; i <= num; i++ {
		d := s[i]
		if k == false && d >= 'A' && d <= 'Z' {
			k = true
		}
		if d >= 'a' && d <= 'z' && (j || k == false) {
			d = d - 32
			j = false
			k = true
		}
		if k && d == '_' && num > i && s[i+1] >= 'a' && s[i+1] <= 'z' {
			j = true
			continue
		}
		data = append(data, d)
	}
	return string(data[:])
}

func fotmatYamlString(descriptor *Descriptor, data *ExcelData) string {
	sb := strings.Builder{}
	for _, row := range data.ValueArr {
		sb.WriteString(fmt.Sprintln("-"))
		for index, v := range row {
			field := data.FieldArr[index]
			if field.Type == field_type_json && v == "" {
				sb.WriteString(fmt.Sprintf("  %s: %s%s", field.FieldName, v, fmt.Sprintln()))
			} else if field.Type == field_type_json {
				sb.WriteString(fmt.Sprintf("  %s: |-%s", field.FieldName, fmt.Sprintln()))
				sb.WriteString(fmt.Sprintf("    %s%s", v, fmt.Sprintln()))
			} else if field.Type == field_type_string {
				sb.WriteString(fmt.Sprintf("  %s: %s%s", field.FieldName, v, fmt.Sprintln()))
			} else {
				sb.WriteString(fmt.Sprintf("  %s: %v%s", field.FieldName, v, fmt.Sprintln()))
			}
		}
	}
	sb.WriteString(fmt.Sprintln())
	return sb.String()
}

type ResourceYaml struct {
	Descriptor map[string]struct {
		Type string   `yaml:"type"`
		File string   `yaml:"file"`
		Keys []string `yaml:"key"`
	} `yaml:"descriptor"`
	Bundle map[string]struct {
		Type  string   `yaml:"type"`
		Files []string `yaml:"files"`
	} `yaml:"bundle"`
	Loader map[string][]string `yaml:"loader"`
}

func (f *ResourceFile) read(filePath string) error {
	if data, err := ioutil.ReadFile(filePath); err != nil {
		return err
	} else {
		result := ResourceYaml{}
		if err := yaml.Unmarshal(data, &result); err != nil {
			return err
		}
		//result := make(map[string]interface{})
		if err := yaml.Unmarshal(data, result); err != nil {
			return err
		}
		{
			descriptors := result.Descriptor
			for name, row := range descriptors {
				var filePath string
				filePath = row.File
				// 类型
				var typ descriptor_type = descriptor_type_array
				if v, ok := descriptor_type_name_dict[row.Type]; ok {
					typ = v
				}
				// 解析key arr
				keyArr := row.Keys
				// xlsx替换成yaml
				yamlFilePath := strings.Replace(filePath, filepath.Ext(filePath), ".yaml", -1)
				descriptor := &Descriptor{
					Type:             typ,
					Name:             name,
					StructName:       name,
					TableName:        name,
					CapStructName:    capLowerString(name),
					ArrTypeName:      name + "Arr",
					MapTypeName:      name + "Map",
					GoObjectTypeName: name + "Object",
					FilePath:         filePath,
					YamlFilePath:     yamlFilePath,
					KeyArr:           keyArr,
				}
				if typ == descriptor_type_array {
					descriptor.WrapStructName = descriptor.ArrTypeName
				} else if typ == descriptor_type_map {
					descriptor.WrapStructName = descriptor.MapTypeName
				} else if typ == descriptor_type_object {
					descriptor.WrapStructName = descriptor.GoObjectTypeName
				}
				f.DescriptorDict[name] = descriptor
				f.DescriptorArr = append(f.DescriptorArr, descriptor)
			}
		}
		{
			bundles := result.Bundle
			for name, row := range bundles {
				descriptorArr := make([]*Descriptor, 0)
				for _, name := range row.Files {
					if bundle, ok := f.DescriptorDict[name]; ok {
						descriptorArr = append(descriptorArr, bundle)
					}
				}
				bundle := &Bundle{
					BundleType:          row.Type,
					BundleName:          name,
					BundleStructName:    camelString(name) + "Bundle",
					CapBundleStructName: capLowerString(camelString(name) + "Bundle"),
					descriptorNameArr:   row.Files,
					DescriptorArr:       descriptorArr,
				}
				f.BundleDict[name] = bundle
				f.BundleArr = append(f.BundleArr, bundle)
			}
		}
		{
			loaders := result.Loader
			for name, rows := range loaders {
				bundleArr := make([]*Bundle, 0)
				for _, name := range rows {
					if bundle, ok := f.BundleDict[name]; ok {
						bundleArr = append(bundleArr, bundle)
					}
				}
				loader := &Loader{
					Name:              name,
					LoaderStructName:  camelString(name) + "Loader",
					HandlerStructName: "I" + camelString(name) + "Handler",
					bundleNameArr:     rows,
					BundleArr:         bundleArr,
				}
				f.LoaderArr = append(f.LoaderArr, loader)
			}
		}
		// 排序
		sort.Sort(SortDescriptorByName(f.DescriptorArr))
		sort.Sort(SortBundleByName(f.BundleArr))
		sort.Sort(SortLoaderByName(f.LoaderArr))
	}
	return nil
}

func (excelData *ExcelData) read(name string, descriptor *Descriptor, filePath string) error {
	f, err := excelize.OpenFile(filePath)
	if err != nil {
		log.Info(err)
		return err
	}
	// 获取 Sheet1 上所有单元格
	rows, err := f.GetRows("Sheet1")
	typeRow := rows[4]
	nameRow := rows[3]
	// 字段名
	for index, v := range nameRow {
		if v != "" {
			typeName := typeRow[index]
			// 字段类型
			if realType, ok := type_name_dict[typeRow[index]]; ok {
				field := &Field{
					FieldName:    v,
					CapFieldName: capUpperString(camelString(v)),
					Type:         realType,
					tag:          index,
					GoTypeName:   go_type_name_dict[realType],
				}
				excelData.FieldArr = append(excelData.FieldArr, field)
				excelData.FieldDict[v] = field
			} else {
				return fmt.Errorf("invalid type %s", typeName)
			}
		}
	}
	descriptor.FieldDict = excelData.FieldDict
	if descriptor.Type == descriptor_type_map || descriptor.Type == descriptor_type_object {
		var name string = ""
		for _, v := range descriptor.KeyArr {
			if field, ok := descriptor.FieldDict[v]; ok {
				name = name + fmt.Sprintf(`map[%s]`, field.GoTypeName)
			} else {
				return fmt.Errorf("descriptor %s key %s not found\n", descriptor.StructName, v)
			}
		}
		name = name + fmt.Sprintf(" *%s", descriptor.StructName)
		descriptor.GoMapTypeName = name
	}

	if descriptor.Type == descriptor_type_map {
		descriptor.GoTypeName = descriptor.GoMapTypeName
	} else if descriptor.Type == descriptor_type_array {
		descriptor.realArrTypeName = fmt.Sprintf("[]* %s", descriptor.StructName)
		descriptor.GoTypeName = descriptor.realArrTypeName
	} else if descriptor.Type == descriptor_type_object {
		for k, v := range excelData.FieldArr {
			if v.FieldName == descriptor.KeyArr[0] {
				descriptor.ObjectKeyIndex = k
				break
			}
		}
	}
	// 值
	for index, row := range rows {
		if index <= 4 {
			continue
		}
		valueArr := make([]interface{}, 0)
		for _, field := range excelData.FieldArr {
			var v interface{}
			if len(row) > field.tag {
				v = row[field.tag]
			} else {
				v = ""
			}
			if field.Type == field_type_string {
			} else if field.Type == field_type_bool {
				if v == "" {
					v = "false"
				}
			} else if field.Type == field_type_json {
			} else {
				if v == "" {
					v = 0
				}
			}
			valueArr = append(valueArr, v)
		}
		excelData.ValueArr = append(excelData.ValueArr, valueArr)
	}
	keyGoTypeNameArr := make([]string, 0)
	for _, k := range descriptor.KeyArr {
		f, _ := excelData.FieldDict[k]
		keyGoTypeNameArr = append(keyGoTypeNameArr, f.GoTypeName)
	}
	descriptor.KeyGoTypeNameArr = keyGoTypeNameArr
	descriptor.FieldArr = excelData.FieldArr
	descriptor.ExcelData = excelData
	return nil
}

func getSrcFileHash(arr []string) string {
	sort.Strings(arr)
	sb := strings.Builder{}
	for _, filePath := range arr {
		if v, err := os.Stat(filePath); err == nil {
			sb.WriteString(fmt.Sprintf("%s %v\n", filePath, v.ModTime()))
		}
	}
	hash := md5.New()
	hash.Write([]byte(sb.String()))
	md5Hash := hex.EncodeToString(hash.Sum(nil))
	return md5Hash
}

func genResources1(state *GenState) error {
	srcFilePathArr := make([]string, 0)
	srcFilePathArr = append(srcFilePathArr, proj.Config.DocResourceFilePath)
	// 解析descriptor
	if err := state.ResourceFile.read(proj.Config.DocResourceFilePath); err != nil {
		return err
	}
	for _, v := range state.ResourceFile.DescriptorArr {
		filePath := path.Join(proj.Config.ExcelDir, v.FilePath)
		srcFilePathArr = append(srcFilePathArr, filePath)
	}
	srcHash := getSrcFileHash(srcFilePathArr)
	if srcHash == proj.Config.GenResourceHash {
		return gira.ErrGenNotChange
	}
	for _, v := range state.ResourceFile.DescriptorArr {
		// 解析excel
		filePath := path.Join(proj.Config.ExcelDir, v.FilePath)
		excelData := &ExcelData{
			FieldDict: make(map[string]*Field, 0),
			FieldArr:  make([]*Field, 0),
			ValueArr:  make([][]interface{}, 0),
		}
		if err := excelData.read(v.Name, v, filePath); err != nil {
			return err
		}
		state.ExcelDataDict[v.Name] = excelData
	}
	proj.Update("gen_resource_hash", srcHash)
	return nil
}

func genResources2(state *GenState) error {
	log.Info("生成yaml文件")
	if _, err := os.Stat(proj.Config.ResourceDir); os.IsNotExist(err) {
		if err := os.Mkdir(proj.Config.ResourceDir, 0755); err != nil {
			return err
		}
	}
	for name, v := range state.ResourceFile.DescriptorDict {
		log.Info(name, "==>", v.YamlFilePath)
		filePath := path.Join(proj.Config.ResourceDir, v.YamlFilePath)
		file, err := os.OpenFile(filePath, os.O_WRONLY|os.O_CREATE, 0644)
		if err != nil {
			return err
		}
		file.Truncate(0)
		if resourceData, ok := state.ExcelDataDict[name]; ok {
			file.WriteString(fotmatYamlString(v, resourceData))
			file.WriteString("\n")
			file.Close()
		} else {
			file.Close()
			return fmt.Errorf("%s not found", name)
		}
	}

	log.Info("生成go文件")
	// sb := strings.Builder{}
	if err := os.RemoveAll(proj.Config.SrcGenResourceDir); err != nil {
		return err
	}
	if err := os.Mkdir(proj.Config.SrcGenResourceDir, 0755); err != nil {
		return err
	}
	funcMap := template.FuncMap{
		"join":        strings.Join,
		"quote":       QuoteChar,
		"capUpper":    capUpperString,
		"camelString": camelString,
	}
	resourcesPath := path.Join(proj.Config.SrcGenResourceDir, "resource.go")
	file, err := os.OpenFile(resourcesPath, os.O_WRONLY|os.O_CREATE, 0644)
	if err != nil {
		return err
	}
	file.Truncate(0)
	defer file.Close()
	tmpl := template.New("resource").Delims("<<", ">>")
	tmpl.Funcs(funcMap)
	if tmpl, err := tmpl.Parse(code); err != nil {
		return err
	} else {
		if err := tmpl.Execute(file, state.ResourceFile); err != nil {
			return err
		}
	}
	return nil
}

func genResources3(state *GenState) error {
	resourceFilePath := path.Join(proj.Config.SrcGenDir, "resource.go")
	file, err := os.OpenFile(resourceFilePath, os.O_WRONLY|os.O_CREATE, 0644)
	if err != nil {
		return err
	}
	file.Truncate(0)
	defer file.Close()
	tmpl := template.New("resource").Delims("<<", ">>")
	if tmpl, err := tmpl.Parse(cli_code); err != nil {
		return err
	} else {
		if err := tmpl.Execute(file, state); err != nil {
			return err
		}
	}
	return nil
}

// 生成协议
func Gen() error {
	log.Info("===============gen resource start===============")
	// 初始化
	genState := &GenState{
		Module:        proj.Config.Module,
		ExcelDataDict: make(map[string]*ExcelData),
		ResourceFile: ResourceFile{
			DescriptorDict: make(map[string]*Descriptor, 0),
			DescriptorArr:  make([]*Descriptor, 0),
			BundleDict:     make(map[string]*Bundle, 0),
			BundleArr:      make([]*Bundle, 0),
			LoaderArr:      make([]*Loader, 0),
		},
	}
	if err := genResources1(genState); err != nil && err == gira.ErrGenNotChange {
		log.Info("===============gen resource finished, not change===============")
		return nil
	} else if err != nil {
		return err
	}
	if err := genResources2(genState); err != nil {
		return err
	}
	if err := genResources3(genState); err != nil {
		return err
	}
	log.Info("===============gen resource finished===============")
	return nil
}
