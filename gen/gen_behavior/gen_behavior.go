package gen_behavior

import (
	"fmt"
	"io/ioutil"
	"os"
	"path"
	"path/filepath"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"text/template"

	"github.com/lujingwei002/gira/log"

	"github.com/lujingwei002/gira/proj"

	yaml "gopkg.in/yaml.v3"
)

var model_template = `
// Code generated by github.com/lujingwei002/gira. DO NOT EDIT.
// Code generated by github.com/lujingwei002/gira. DO NOT EDIT.
// Code generated by github.com/lujingwei002/gira. DO NOT EDIT.

package <<.DbName>> 

// mongo模型
import (
	"github.com/lujingwei002/gira"
	"github.com/lujingwei002/gira/log"
	"github.com/lujingwei002/gira/behavior"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
	yaml "gopkg.in/yaml.v3"
	"context"
	"bufio"
	"os"
	"sync"
	"io"
	"time"
)





<<- range .CollectionArr>> 


<</* 模型Data */>>
type <<.StructName>> struct {
	<<- range .FieldArr>> 
	/// <<.Comment>>
	<<.CamelName>> <<.GoTypeName>> <<quote>>bson:"<<.Name>>" json:"<<.Name>>"<<quote>>
	<<- end>>
}

<<- end>> 


// mongo 
type <<.MongoDbStructName>> struct {
	client		*mongo.Client
	database	*mongo.Database
	<<- range .CollectionArr>> 
	<<.StructName>>  *<<.MongoDaoStructName>>
	<<- end>>
}

var globalDriver *<<.MongoDbStructName>>

func NewMongo() *<<.MongoDbStructName>> {
	self := &<<.MongoDbStructName>>{}
	<<- range .CollectionArr>> 
	self.<<.StructName>> = &<<.MongoDaoStructName>>{
		db: self,
		models: make([]mongo.WriteModel, 0),
	}
	<<- end>> 
	return self
}

func UseMongo(client gira.MongoClient) error {
	if globalDriver != nil {
		return gira.ErrTodo
	}
	globalDriver = NewMongo()
	return globalDriver.Use(client)
}

func Serve(ctx context.Context, config gira.BehaviorDbConfig) error {
	if globalDriver == nil {
		return gira.ErrBehaviorNotInit
	}
	return globalDriver.Serve(ctx, config)
}

func Sync(ctx context.Context, opts ...behavior.SyncOption) error {
	if globalDriver == nil {
		return gira.ErrBehaviorNotInit
	}
	return globalDriver.Sync(ctx, opts...)
}

func (self *<<.MongoDbStructName>>) Use(client gira.MongoClient) error {
	self.client = client.GetMongoClient()
	self.database = client.GetMongoDatabase()
	return nil
}

func (self *<<.MongoDbStructName>>) Serve(ctx context.Context, config gira.BehaviorDbConfig) (err error) {
	ticker := time.NewTicker(time.Duration(config.SyncInterval)*time.Second)
	defer func() {
		ticker.Stop()
	}()
	opts := make([]behavior.SyncOption, 0)
	if config.BatchInsert != 0 {
		opts = append(opts, behavior.WitchBatchInsertOption(config.BatchInsert))
	}
	for {
		select {
		case <-ctx.Done():
			self.Sync(context.TODO())
			return nil
		case <-ticker.C:
			self.Sync(ctx, opts...)
		}
	}
}

func (self *<<.MongoDbStructName>>) Sync(ctx context.Context, opts ...behavior.SyncOption) (err error) {
<<- range .CollectionArr>>
	if _, err = self.<<.StructName>>.Sync(ctx, opts...); err != nil {
		log.Error(err)
	} else {

	}
<<- end>> 
	return 
}



<<- range .CollectionArr>> 

type <<.MongoDaoStructName>> struct {
	db 		*<<$.MongoDbStructName>>
	models	[]mongo.WriteModel
	mu		sync.Mutex
}

// <<.Comment>>
func Log<<.StructName>>(doc *<<.StructName>>) error {
	return globalDriver.<<.StructName>>.Log(doc)
}

// <<.Comment>>
func (self *<<.MongoDaoStructName>>) Log(doc *<<.StructName>>) error {
	doc.Id = primitive.NewObjectID()
	doc.LogTime = time.Now().Unix()
	log.Infow("<<.CollName>>",
	<<- range .FieldArr>> 
		"<<.Name>>", doc.<<.CamelName>>, // <<.Comment>>
	<<- end>>
	)
	self.mu.Lock()
	self.models = append(self.models, mongo.NewInsertOneModel().SetDocument(doc))
	self.mu.Unlock()
	return nil
}

func (self *<<.MongoDaoStructName>>) Sync(ctx context.Context, opts ...behavior.SyncOption) (n int, err error) {
	syncOptions := &behavior.SyncOptions {
	}
	for _, v := range opts {
		v.ConfigSyncOptions(syncOptions)
	}
	database := self.db.database
	coll := database.Collection("<<.CollName>>")
	if len(self.models) <= 0 {
		return
	}
	self.mu.Lock()
	var models []mongo.WriteModel
	if syncOptions.Step != 0 && syncOptions.Step <= len(self.models) {
		models = self.models[:syncOptions.Step]
		self.models = self.models[syncOptions.Step:]
	} else {
		models = self.models
		self.models = make([]mongo.WriteModel, 0)
	}
	self.mu.Unlock()
	for _, model := range models {
		v := model.(*mongo.InsertOneModel)
		doc := v.Document.(*<<.StructName>>)
		doc.CreateTime = time.Now().Unix()
	}
	writeOpts := options.BulkWrite().SetOrdered(false)
	_, err = coll.BulkWrite(ctx, models, writeOpts)
	if err != nil {
		self.mu.Lock()
		self.models = append(self.models, models...)
		self.mu.Unlock()
		log.Errorw("sync behavior fail", "name", "<<.CollName>>", "len", len(models), "error", err)
	    return
	} else {
		log.Infow("sync behavior", "name", "<<.CollName>>", "len", len(models))
		n = len(models)
		return 
	}
}

func (self *<<.MongoDaoStructName>>) BatchWrite(ctx context.Context, filePath string) error {
	f, err := os.OpenFile(filePath, os.O_RDONLY, 0666)
    if err != nil {
        return err
    }
	database := self.db.database
	coll := database.Collection("<<.CollName>>")
	models := make([]mongo.WriteModel, 0)
    defer f.Close()
    reader := bufio.NewReader(f)
    // 按行处理txt
    for  {
        line, _, err := reader.ReadLine()
        if err == io.EOF {
            break
        }
		doc := <<.StructName>> {
		}
		if err := yaml.Unmarshal(line, &doc); err != nil {
			return err
		}
		models = append(models, mongo.NewInsertOneModel().SetDocument(&doc))
    }
	if len(models) <= 0 {
		return nil
	}
	opts := options.BulkWrite().SetOrdered(false)
	_, err = coll.BulkWrite(ctx, models, opts)
	if err != nil {
		log.Error(err)
	    return err
	}
	return nil
}
<<- end>>





`

type field_type int

const (
	field_type_int field_type = iota
	field_type_int32
	field_type_int64
	field_type_string
	field_type_message
	field_type_objectid
	field_type_bool
	field_type_bytes
	field_type_int_arr
	field_type_int64_arr
	field_type_struct
)

const field_id_name string = "id"

var type_name_dict = map[string]field_type{
	"int":     field_type_int,
	"int32":   field_type_int32,
	"int64":   field_type_int64,
	"string":  field_type_string,
	"id":      field_type_objectid,
	"bool":    field_type_bool,
	"bytes":   field_type_bytes,
	"[]int":   field_type_int_arr,
	"[]int64": field_type_int64_arr,
}

var go_type_name_dict = map[field_type]string{
	field_type_int:       "int64",
	field_type_int32:     "int32",
	field_type_int64:     "int64",
	field_type_string:    "string",
	field_type_objectid:  "primitive.ObjectID",
	field_type_bool:      "bool",
	field_type_bytes:     "[]byte",
	field_type_int_arr:   "[]int64",
	field_type_int64_arr: "[]int64",
}

var protobuf_type_name_dict = map[field_type]string{
	field_type_int:       "int64",
	field_type_int32:     "int32",
	field_type_int64:     "int64",
	field_type_string:    "string",
	field_type_objectid:  "string",
	field_type_bool:      "bool",
	field_type_bytes:     "bytes",
	field_type_int64_arr: "repeated int64",
	field_type_int_arr:   "repeated int64",
}

type message_type int

const (
	message_type_struct message_type = iota
	message_type_request
	message_type_response
	message_type_notify
	message_type_push
)

type Field struct {
	Tag              int
	Name             string
	CamelName        string
	Type             field_type
	Array            bool
	TypeName         string
	GoTypeName       string
	ProtobufTypeName string
	Default          interface{}
	Comment          string
	Coll             *Collection
}
type SortFieldByName []*Field

func (self SortFieldByName) Len() int           { return len(self) }
func (self SortFieldByName) Swap(i, j int)      { self[i], self[j] = self[j], self[i] }
func (self SortFieldByName) Less(i, j int) bool { return self[i].Tag < self[j].Tag }

func (f *Field) IsComparable() bool {
	switch f.GoTypeName {
	case "int32":
	case "int":
	case "int64":
	case "string":
	case "bool":
	case "primitive.ObjectID":
		return true
	default:
		return false
	}
	return false
}

func (f *Field) IsStruct() bool {
	return f.Type == field_type_struct
}

func capLowerString(s string) string {
	if len(s) <= 0 {
		return s
	}
	return strings.ToLower(s[0:1]) + s[1:]
}

func camelString(s string) string {
	data := make([]byte, 0, len(s))
	j := false
	k := false
	num := len(s) - 1
	for i := 0; i <= num; i++ {
		d := s[i]
		if k == false && d >= 'A' && d <= 'Z' {
			k = true
		}
		if d >= 'a' && d <= 'z' && (j || k == false) {
			d = d - 32
			j = false
			k = true
		}
		if k && d == '_' && num > i && s[i+1] >= 'a' && s[i+1] <= 'z' {
			j = true
			continue
		}
		data = append(data, d)
	}
	return string(data[:])
}

type Collection struct {
	CollName           string // 表名
	StructName         string // 表名的驼峰格式
	MongoDaoStructName string // mongo dao 结构的名称
	Derive             string
	DataStructName     string
	Comment            string
	FieldDict          map[string]*Field
	FieldArr           []*Field
}
type SortCollectionByName []*Collection

func (self SortCollectionByName) Len() int           { return len(self) }
func (self SortCollectionByName) Swap(i, j int)      { self[i], self[j] = self[j], self[i] }
func (self SortCollectionByName) Less(i, j int) bool { return self[i].CollName < self[j].CollName }

type Database struct {
	Module            string
	Driver            string
	DbStructName      string // 数据库名的驼峰格式
	MongoDbStructName string // mongo 的 dao 结构名字
	DbName            string
	GenModelFilePath  string        // 生成的文件路径，在 gen/{{DbName}}//{{DbName}}.go
	CollectionArr     []*Collection // 所有的模型
}

// 生成协议的状态
type gen_state struct {
	databaseArr []*Database
}

func QuoteChar() interface{} {
	return "`"
}

func (descriptor *Collection) IsDeriveUser() bool {
	return descriptor.Derive == "user"
}

func (descriptor *Collection) IsDeriveUserArr() bool {
	return descriptor.Derive == "userarr"
}

func (descriptor *Collection) parseStruct(attrs map[string]interface{}) error {
	descriptor.FieldDict = make(map[string]*Field)
	descriptor.FieldArr = make([]*Field, 0)
	spaceRegexp := regexp.MustCompile("[^\\s]+")
	equalRegexp := regexp.MustCompile("[^=]+")

	for valueStr, v := range attrs {
		var tag int
		var err error
		var fieldName string
		var typeStr string
		var tagStr string
		var optionArr []interface{}
		switch v.(type) {
		case nil:
			break
		case []interface{}:
			optionArr = v.([]interface{})
		default:
			return fmt.Errorf("%+v invalid11", v)
		}
		args := equalRegexp.FindAllString(valueStr, -1)
		if len(args) != 2 {
			return fmt.Errorf("%s invalid", valueStr)
		}
		tagStr = strings.TrimSpace(args[1])
		if tag, err = strconv.Atoi(tagStr); err != nil {
			return err
		}
		args = spaceRegexp.FindAllString(args[0], -1)
		if len(args) != 2 {
			return fmt.Errorf("%s invalid", valueStr)
		}
		typeStr = args[1]
		fieldName = args[0]
		field := &Field{
			Coll:      descriptor,
			Name:      fieldName,
			CamelName: camelString(fieldName),
			Array:     false,
			Tag:       tag,
		}
		if fieldName == "id" {
			field.Name = "_id"
			field.CamelName = "Id"
		} else {
			field.Name = fieldName
			field.CamelName = camelString(fieldName)
		}
		field.TypeName = typeStr
		if typeValue, ok := type_name_dict[typeStr]; ok {
			field.Type = typeValue
			field.GoTypeName = go_type_name_dict[field.Type]
			field.ProtobufTypeName = protobuf_type_name_dict[field.Type]
		} else {
			field.Type = field_type_struct
			field.GoTypeName = typeStr
			field.ProtobufTypeName = "bytes"
		}

		// fmt.Println(optionArr)
		for _, option := range optionArr {
			optionDict := option.(map[string]interface{})
			if defaultVal, ok := optionDict["default"]; ok {
				field.Default = defaultVal
			}
			if comment, ok := optionDict["comment"]; ok {
				field.Comment = comment.(string)
			}
		}

		descriptor.FieldDict[fieldName] = field
		descriptor.FieldArr = append(descriptor.FieldArr, field)
	}
	sort.Sort(SortFieldByName(descriptor.FieldArr))
	return nil
}

func (descriptor *Collection) Unmarshal(genState *gen_state, v interface{}) error {
	var derive string
	row := v.(map[string]interface{})
	if _, ok := row["struct"]; !ok {
		return fmt.Errorf("collection %s struct part not found", descriptor.CollName)
	}
	structPart := row["struct"]
	if _, ok := structPart.(map[string]interface{}); !ok {
		return fmt.Errorf("collection %s struct part not map", descriptor.CollName)
	}
	descriptor.Derive = derive
	if err := descriptor.parseStruct(row["struct"].(map[string]interface{})); err != nil {
		return err
	}
	if v, ok := row["comment"]; ok {
		descriptor.Comment = v.(string)
	}
	return nil
}

func parse(state *gen_state, filePathArr []string) error {
	for _, fileName := range filePathArr {
		filePath := path.Join(proj.Config.DocBehaviorDir, fileName)
		log.Info("处理文件", filePath)
		data, err := ioutil.ReadFile(filePath)
		if err != nil {
			return err
		}
		dbName := strings.Replace(fileName, ".yaml", "", 1)
		database := &Database{
			Module:            proj.Config.Module,
			CollectionArr:     make([]*Collection, 0),
			GenModelFilePath:  path.Join(proj.Config.SrcGenBehaviorDir, dbName, fmt.Sprintf("%s.gen.go", dbName)),
			DbName:            dbName,
			DbStructName:      camelString(dbName),
			MongoDbStructName: fmt.Sprintf("%sMongoDriver", camelString(dbName)),
		}
		result := make(map[string]interface{})
		if err := yaml.Unmarshal(data, result); err != nil {
			return err
		}
		for k, v := range result {
			if k == "$driver" {
				database.Driver = v.(string)
			} else {
				collName := k
				coll := &Collection{
					CollName:           collName,
					StructName:         camelString(collName),
					DataStructName:     fmt.Sprintf("%sData", camelString(collName)),
					MongoDaoStructName: fmt.Sprintf("%sMongoDao", camelString(collName)),
				}
				if err := coll.Unmarshal(state, v); err != nil {
					return err
				}
				database.CollectionArr = append(database.CollectionArr, coll)
			}
		}
		sort.Sort(SortCollectionByName(database.CollectionArr))
		state.databaseArr = append(state.databaseArr, database)
	}
	return nil
}

func genModel(protocolState *gen_state) error {
	for _, db := range protocolState.databaseArr {

		dir := path.Dir(db.GenModelFilePath)
		if _, err := os.Stat(dir); err != nil {
			if os.IsNotExist(err) {
				if err := os.Mkdir(dir, 0755); err != nil {
					return err
				}
			} else {
				return err
			}
		}

		var err error
		file, err := os.OpenFile(db.GenModelFilePath, os.O_WRONLY|os.O_CREATE, 0644)
		if err != nil {
			return err
		}
		file.Truncate(0)
		funcMap := template.FuncMap{
			"quote": QuoteChar,
		}
		tmpl := template.New("model").Delims("<<", ">>")
		tmpl.Funcs(funcMap)
		tmpl, err = tmpl.Parse(model_template)
		if err != nil {
			return err
		}
		if err = tmpl.Execute(file, db); err != nil {
			return err
		}
		file.Close()
	}
	return nil
}

// 生成协议
func Gen() error {
	log.Info("===============gen behavior start===============")
	if _, err := os.Stat(proj.Config.SrcGenBehaviorDir); err != nil {
		if os.IsNotExist(err) {
			if err := os.Mkdir(proj.Config.SrcGenBehaviorDir, 0755); err != nil {
				return err
			}
		} else {
			return err
		}
	}
	fileNameArr := make([]string, 0)
	if err := filepath.WalkDir(proj.Config.DocBehaviorDir, func(path string, d os.DirEntry, err error) error {
		if d == nil {
			return nil
		}
		if d.IsDir() {
			return nil
		}
		if filepath.Ext(d.Name()) == ".yaml" {
			fileNameArr = append(fileNameArr, d.Name())
		}
		return nil
	}); err != nil {
		return err
	}
	sort.Strings(fileNameArr)
	genState := &gen_state{
		databaseArr: make([]*Database, 0),
	}
	if err := parse(genState, fileNameArr); err != nil {
		log.Info(err)
		return err
	}
	if err := genModel(genState); err != nil {
		log.Info(err)
		return err
	}
	log.Info("===============gen behavior finished===============")
	return nil
}
