package gen_protocol

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/lujingwei002/gira/log"

	"github.com/lujingwei002/gira/proj"
)

type field_type int

var sproto_template = `
<<.Header>>
<<- range .PacketArr>>
<<- range .CommentArr>>
#<<.>>
<<- end>>
<<if .Type.IsStructType>>.<<.StructName>><<else>><<.Name>> <<.MessageId>><<- end>> {

	<<- if .Type.IsStructType>>
	<<- range .Message.FieldArr>>
	<<- range .CommentArr>>
	#<<.>>
	<<- end>>
    <<.Name>> <<.Tag>> : <<- if .IsArray>>*<<- end>><<.SpTypeName>>
	<<- end>>
	<<- end>>

	<<- if .Type.IsRequestType>>
    request {
		<<- range .Request.FieldArr>>
		<<- range .CommentArr>>
		#<<.>>
		<<- end>>
		<<.Name>> <<.Tag>> : <<- if .IsArray>>*<<- end>><<.SpTypeName>>
		<<- end>>
	}
	response {
		<<- range .Response.FieldArr>>
		<<- range .CommentArr>>
		#<<.>>
		<<- end>>
		<<.Name>> <<.Tag>> : <<- if .IsArray>>*<<- end>><<.SpTypeName>>
		<<- end>>
	}
	<<- end>>

	<<- if .Type.IsNotifyType>>
	response {
		<<- range .Notify.FieldArr>>
		<<- range .CommentArr>>
		#<<.>>
		<<- end>>
		<<.Name>> <<.Tag>> : <<- if .IsArray>>*<<- end>><<.SpTypeName>>
		<<- end>>
	}
	<<- end>>

	<<- if .Type.IsPushType>>
    request {
		<<- range .Push.FieldArr>>
		<<- range .CommentArr>>
		#<<.>>
		<<- end>>
		<<.Name>> <<.Tag>> : <<- if .IsArray>>*<<- end>><<.SpTypeName>>
		<<- end>>
	}
	<<- end>>
}
<<end>>
`

var sproto_go_template = `
// Code generated by github.com/lujingwei002/gira. DO NOT EDIT.
// Code generated by github.com/lujingwei002/gira. DO NOT EDIT.
// Code generated by github.com/lujingwei002/gira. DO NOT EDIT.

package <<.Module>>

import (
	"reflect"
	"context"
	gosproto "github.com/xjdrew/gosproto"
	"github.com/lujingwei002/gira"
	"github.com/lujingwei002/gira/log"
	//"github.com/lujingwei002/gira/sproto"
	"sync/atomic"
	"sync"
)

var _ reflect.Type

<<- range .PacketArr>>
	<<- /* struct 类型 */>>
	<<- if .Type.IsStructType>>
type <<.Message.StructName>> struct {
	<<- range .Message.FieldArr>>
	<<- range .CommentArr>>
	//<<.>>
	<<- end>>
    <<.CamelName>> <<if .IsArray>>[]<<end>><<.GoTypeName>> <<quote>>sproto:"<<.SpWireTypeName>>,<<.Tag>><<if .IsArray>>,array<<end>>"<<quote>>
	<<- end>>
}
	<<end>>
	<<- /* request 类型 */>>
	<<- if .Type.IsRequestType>>
type <<.Request.StructName>> struct {
	<<- range .Request.FieldArr>>
	<<- range .CommentArr>>
	//<<.>>
	<<- end>>
    <<.CamelName>> <<if .IsArray>>[]<<end>><<.GoTypeName>> <<quote>>sproto:"<<.SpWireTypeName>>,<<.Tag>><<if .IsArray>>,array<<end>>"<<quote>>
	<<- end>>
}

type <<.Response.StructName>> struct {
	<<- range .Response.FieldArr>>
	<<- range .CommentArr>>
	//<<.>>
	<<- end>>
    <<.CamelName>> <<if .IsArray>>[]<<end>><<.GoTypeName>> <<quote>>sproto:"<<.SpWireTypeName>>,<<.Tag>><<if .IsArray>>,array<<end>>"<<quote>>
	<<- end>>
}

func (self *<<.Request.StructName>>) GetRequestName() string {
	return "<<.StructName>>"
}

<<- range .Request.FieldArr>>
<<- range .CommentArr>>
//<<.>>
<<- end>>
func (self *<<.Message.StructName>>) Get<<.CamelName>>() <<if .IsArray>>[]<<end>><<.GoTypeName>> {
	return self.<<.CamelName>> 
}
<<- end>>

func (self *<<.Response.StructName>>) SetErrorCode(v int32) {
	self.ErrorCode = v
}
func (self *<<.Response.StructName>>) SetErrorMsg(v string) {
	self.ErrorMsg = v
}
<<end>>
	<<- /* notify 类型 */>>
	<<- if .Type.IsNotifyType>>
type <<.Notify.StructName>> struct {
	<<- range .Notify.FieldArr>>
	<<- range .CommentArr>>
	//<<.>>
	<<- end>>
    <<.CamelName>> <<if .IsArray>>[]<<end>><<.GoTypeName>> <<quote>>sproto:"<<.SpWireTypeName>>,<<.Tag>><<if .IsArray>>,array<<end>>"<<quote>>
	<<- end>>
}

	<<end>>
	<<- /* push 类型 */>>
	<<- if .Type.IsPushType>>
type <<.Push.StructName>> struct {
	<<- range .Push.FieldArr>>
	<<- range .CommentArr>>
	//<<.>>
	<<- end>>
    <<.CamelName>> <<if .IsArray>>[]<<end>><<.GoTypeName>> <<quote>>sproto:"<<.SpWireTypeName>>,<<.Tag>><<if .IsArray>>,array<<end>>"<<quote>>
	<<- end>>
}

func (self *<<.Push.StructName>>) GetPushName() string {
	return "<<.StructName>>"
}
	<<end>>
<<- end>>

var Protocols []*gosproto.Protocol = []*gosproto.Protocol {
<<- range .PacketArr>>
<<- if .Type.IsStructType>>
<<- else>>
	{
		Type: 		<<.MessageId>>,
		Name: 		"<<.StructName>>",
		MethodName: "<<.StructName>>",
	<<- if .Type.IsPushType>>
		Request: reflect.TypeOf(&<<.Push.StructName>>{}),
	<<- end>>
	<<- if .Type.IsNotifyType>>
		Request: reflect.TypeOf(&<<.Notify.StructName>>{}),
	<<- end>>
	<<- if .Type.IsRequestType>>
		Request: reflect.TypeOf(&<<.Request.StructName>>{}),
		Response: reflect.TypeOf(&<<.Response.StructName>>{}),
	<<- end>>
	},
<<- end>>
<<- end>>
}


type Client struct {
	proto			gira.Proto
	conn			gira.GatewayClient
	reqId			uint64
	ctx				context.Context
	requestDict     sync.Map
	// 末处理的push, 只保留最后一个
	pendingPushDict sync.Map
	waitPushDict    sync.Map
	onPushDict		map[string]*sync.Map

	// push 消息的侦听函数 
<<- range .PacketArr>>
<<- if .Type.IsPushType>>
	<< capLower .Push.StructName>>Func	sync.Map
	<< capLower .Push.StructName>>Id	uint64
<<- end>>
<<- end>>
	// push 消息的侦听函数 
}

type PushMethod interface {
	Call(req gira.ProtoPush, err error)
}

<<- range .PacketArr>>
<<- if .Type.IsPushType>>
type <<.Push.StructName>>Func func (req *<<.Push.StructName>>, err error) 

type <<.Push.StructName>>Method struct {
	Func <<.Push.StructName>>Func
}

func (self* <<.Push.StructName>>Method) Call(req gira.ProtoPush, err error) {
	r := req.(*<<.Push.StructName>>)
	self.Func(r, err)
}

<<- end>>
<<- end>>

type waitRequest struct {
	route	string
	data	[]byte
	err		error
    caller	chan*waitRequest
	reqId	uint64
	name    string
	session int32
	resp    interface{}
}

type waitPush struct {
	route	string
	data	[]byte
	err		error
    caller	chan*waitPush
	name    string
	session int32
	resp    interface{}
}

func NewClient(ctx context.Context, conn gira.GatewayClient, sproto gira.Proto) *Client {
	self := &Client{
		proto:		sproto,
		conn:		conn,
		ctx:		ctx,
		onPushDict:	make(map[string]*sync.Map, 0),
	}
<<- range .PacketArr>>
<<- if .Type.IsPushType>>
	self.onPushDict["<<.StructName>>"] = &self.<<capLower .Push.StructName>>Func 
<<- end>>
<<- end>>
	go self.readRoutine()
	return self
}

func (self *Client) readRoutine() error {
	cancelCtx, cancelFunc := context.WithCancel(self.ctx)
	defer cancelFunc()
	for {
		typ, route, reqId, data, err := self.conn.Recv(cancelCtx)
		if err != nil {
			//log.Info("client read routine exit", err)
			self.requestDict.Range(func(k any, v any) bool {
				wait := v.(*waitRequest)
				wait.err = err
				wait.caller <- wait	
				return true
			})
			return err
		}
		switch typ {
			case gira.GatewayMessageType_RESPONSE:
				if v, ok := self.requestDict.Load(reqId); ok {
					self.requestDict.Delete(reqId)
					wait := v.(*waitRequest)	
					wait.data = data
					// 上下文信息
					wait.route = route
					wait.reqId = reqId
					// 解析message
					wait.name, wait.session, wait.resp, wait.err = self.proto.ResponseDecode(data)
					wait.caller <- wait
				}
			case gira.GatewayMessageType_PUSH:
				name, _, resp, err := self.proto.PushDecode(data)
				log.Infow("recv push message", "name", name, "data", resp)
				handlerCount := 0
				if dict, ok := self.onPushDict[name]; ok {
					dict.Range(func(k any, v any) bool {
						handlerCount = handlerCount + 1
						f := v.(PushMethod)
						f.Call(resp.(gira.ProtoPush), err)
						return true
					})
				}
				if v, ok := self.waitPushDict.Load(name); ok {
					handlerCount = handlerCount + 1
					self.waitPushDict.Delete(name)
					wait := v.(*waitPush)	
					wait.data = data
					// 上下文信息
					wait.route = route
					// 解析message
					wait.name, wait.session, wait.resp, wait.err = self.proto.PushDecode(data)
					wait.caller <- wait
				}
				if handlerCount == 0 {
					self.pendingPushDict.Store(name, resp)
					// log.Warnw("client proto push not register", "name", name)
				}
		}
	}
}

<<- range .PacketArr>>

<<- if .Type.IsRequestType>>
<<- range .CommentArr>>
//<<.>>
<<- end>>
func (self *Client) <<.StructName>>(ctx context.Context, req *<<.Request.StructName>>) (*<<.Response.StructName>>, error) {
	reqId := atomic.AddUint64(&self.reqId, 1)
	data, err := self.proto.RequestEncode("<<.StructName>>", int32(reqId), req)
	if err != nil {
		return nil, err
	}
	wait := &waitRequest {
		caller: make(chan* waitRequest, 1),
	}
	if _, loaded := self.requestDict.LoadOrStore(reqId, wait); loaded {
		return nil, gira.ErrSprotoReqIdConflict
	}
	if err := self.conn.Request("", reqId, data); err != nil {
		return nil, err
	}
	defer func() {
		self.requestDict.Delete(reqId)
		close(wait.caller)
	}()
	select {
		case v := <- wait.caller:
			if v.err != nil {
				return nil, v.err
			}
	        if uint64(wait.session) != wait.reqId {
				return nil, gira.ErrSprotoResponseConversion 
			}
			resp1, ok := wait.resp.(*<<.Response.StructName>>)
			if !ok {
				return nil, gira.ErrSprotoResponseConversion
			}
			return resp1, nil
		case <-ctx.Done():
			return nil, gira.ErrSprotoReqTimeout
	}
}
<<- end>>


<<- if .Type.IsPushType>>

<<- range .CommentArr>>
//<<.>>
<<- end>>
func (self *Client) Wait<<.StructName>>Push(ctx context.Context) (*<<.Push.StructName>>, error) {
	wait := &waitPush {
		caller: make(chan* waitPush, 1),
	}
	if v, ok := self.pendingPushDict.Load("<<.StructName>>"); ok {
		if resp, ok := v.(*<<.Push.StructName>>); ok {
			return resp, nil
		}
	} 
	if _, loaded := self.waitPushDict.LoadOrStore("<<.StructName>>", wait); loaded {
		return nil, gira.ErrSprotoWaitPushConflict
	}
	defer close(wait.caller)
	select {
		case v := <- wait.caller:
			if v.err != nil {
				return nil, v.err
			}
			resp1, ok := wait.resp.(*<<.Push.StructName>>)
			if !ok {
				return nil, gira.ErrSprotoPushConversion
			}
			return resp1, nil
		case <-ctx.Done():
			return nil, gira.ErrSprotoWaitPushTimeout
	}
}

func (self *Client) On<<.StructName>>Push(f <<.Push.StructName>>Func) uint64 {
	id := atomic.AddUint64(&self.<< capLower .Push.StructName>>Id, 1)
	method := &<<.Push.StructName>>Method {
		Func: f,
	}
	self.<<capLower .Push.StructName>>Func.Store(id, method)
	return id
}

func (self *Client) Off<<.StructName>>Push(id uint64) error {
	self.<<capLower .Push.StructName>>Func.Delete(id)
	return nil
}

<<- end>>
<<- end>>

`

var sproto_go_template2 = `
// Code generated by github.com/lujingwei002/gira. DO NOT EDIT.
// Code generated by github.com/lujingwei002/gira. DO NOT EDIT.
// Code generated by github.com/lujingwei002/gira. DO NOT EDIT.

package <<.Module>>

import (
	"reflect"
	"context"
	gosproto "github.com/xjdrew/gosproto"
	"github.com/lujingwei002/gira"
	"github.com/lujingwei002/gira/log"
	//"github.com/lujingwei002/gira/sproto"
	"sync/atomic"
	"sync"
)

var _ reflect.Type

<<- range .PacketArr>>
	<<- /* struct 类型 */>>
	<<- if .Type.IsStructType>>
	<<- range .CommentArr>>
	//<<.>>
	<<- end>>
type <<.Name>> struct {
	Model struct {
	<<- range .Message.FieldArr>>
	<<- range .CommentArr>>
	//<<.>>
	<<- end>>
    <<.Name>> <<if .IsArray>>[]<<end>><<.GoTypeName>> <<quote>><<.Tag>><<quote>>
	<<- end>>
	}
}
	<<end>>
	<<- /* request 类型 */>>
	<<- if .Type.IsRequestType>>
<<- range .CommentArr>>
//<<.>>
<<- end>>
type <<.Name>> struct {
	MessageId int <<quote>><<.MessageId>><<quote>>
	Request struct {
	<<- range .Request.FieldArr>>
	<<- range .CommentArr>>
	//<<.>>
	<<- end>>
    <<.Name>> <<if .IsArray>>[]<<end>><<.GoTypeName>> <<quote>><<.Tag>><<quote>>
	<<- end>>
	}

	Response struct {
		<<- range .Response.FieldArr>>
	<<- range .CommentArr>>
	//<<.>>
	<<- end>>
    <<.Name>> <<if .IsArray>>[]<<end>><<.GoTypeName>> <<quote>><<.Tag>><<quote>> 
	<<- end>>
	}
}

<<end>>
	<<- /* notify 类型 */>>
	<<- if .Type.IsNotifyType>>
<<- range .CommentArr>>
//<<.>>
<<- end>>
type <<.Name>> struct {
	MessageId int <<quote>><<.MessageId>><<quote>>
	Response struct {
	<<- range .Notify.FieldArr>>
	<<- range .CommentArr>>
	//<<.>>
	<<- end>>
    <<.Name>> <<if .IsArray>>[]<<end>><<.GoTypeName>> <<quote>><<.Tag>><<quote>>
	<<- end>>
	}
}

	<<end>>
	<<- /* push 类型 */>>
	<<- if .Type.IsPushType>>
<<- range .CommentArr>>
//<<.>>
<<- end>>
type <<.Name>> struct {
	MessageId int <<quote>><<.MessageId>><<quote>>
	Request struct {
	<<- range .Push.FieldArr>>
	<<- range .CommentArr>>
	//<<.>>
	<<- end>>
    <<.Name>> <<if .IsArray>>[]<<end>><<.GoTypeName>> <<quote>><<.Tag>><<quote>> 
	<<- end>>
	}
}


	<<end>>
<<- end>>



`

const (
	field_type_int field_type = iota

	field_type_int32
	field_type_int64
	field_type_string
	field_type_struct
	field_type_bool
)

var type_name_dict = map[string]field_type{
	"int":    field_type_int,
	"int32":  field_type_int32,
	"int64":  field_type_int64,
	"string": field_type_string,
	"bool":   field_type_bool,
}

// proto文件类型
var sp_type_name_dict = map[field_type]string{
	field_type_int:    "integer",
	field_type_int32:  "integer",
	field_type_int64:  "integer",
	field_type_string: "string",
	field_type_bool:   "boolean",
}

// go文件类型
var go_type_name_dict = map[field_type]string{
	field_type_int:    "int",
	field_type_int32:  "int32",
	field_type_int64:  "int64",
	field_type_string: "string",
	field_type_bool:   "bool",
}

type MessageType int

const (
	message_type_struct MessageType = iota
	message_type_request
	message_type_response
	message_type_notify
	message_type_push
)

type Field struct {
	Tag            int
	Name           string
	CamelName      string
	Type           field_type
	TypeName       string // 描述文件里的类型
	SpTypeName     string // proto文件的类型
	SpWireTypeName string // go结构体中,tag里的sproto类型
	GoTypeName     string
	Default        interface{}
	IsArray        bool
	CommentArr     []string
	Message        *Message
}

type Message struct {
	StructName string
	FieldDict  map[string]*Field
	FieldArr   []*Field
}

func (s MessageType) IsStructType() bool {
	return s == message_type_struct
}

func (s MessageType) IsRequestType() bool {
	return s == message_type_request
}

func (s MessageType) IsSResponseType() bool {
	return s == message_type_response
}

func (s MessageType) IsNotifyType() bool {
	return s == message_type_notify
}

func (s MessageType) IsPushType() bool {
	return s == message_type_push
}

type Packet struct {
	MessageId  int
	CommentArr []string
	Name       string
	FullName   string
	StructName string
	Type       MessageType
	Message    *Message
	Request    *Message
	Response   *Message
	Push       *Message
	Notify     *Message
}

func capUpperString(s string) string {
	return strings.ToUpper(s[0:1]) + s[1:]
}

func capLowerString(s string) string {
	return strings.ToLower(s[0:1]) + s[1:]
}

func quoteChar() interface{} {
	return "`"
}

func camelString(s string) string {
	data := make([]byte, 0, len(s))
	j := false
	k := false
	num := len(s) - 1
	for i := 0; i <= num; i++ {
		d := s[i]
		if k == false && d >= 'A' && d <= 'Z' {
			k = true
		}
		if d >= 'a' && d <= 'z' && (j || k == false) {
			d = d - 32
			j = false
			k = true
		}
		if k && d == '_' && num > i && s[i+1] >= 'a' && s[i+1] <= 'z' {
			j = true
			continue
		}
		data = append(data, d)
	}
	return string(data[:])
}

// 生成协议的状态
type gen_state struct {
	protocols []*protocol
}

type protocol struct {
	Module     string
	Header     string
	PacketDict map[string]*Packet
	PacketArr  []*Packet
}

func genSproto(genState *gen_state, proto *protocol) error {
	dir := filepath.Join(proj.Config.GenProtocolDir, proto.Module)
	if _, err := os.Stat(proj.Config.GenProtocolDir); os.IsNotExist(err) {
		if err := os.Mkdir(proj.Config.GenProtocolDir, 0755); err != nil {
			return err
		}
	}
	if _, err := os.Stat(dir); os.IsNotExist(err) {
		if err := os.Mkdir(dir, 0755); err != nil {
			return err
		}
	}
	filePath := filepath.Join(dir, fmt.Sprintf("%s.sproto", proto.Module))
	file, err := os.OpenFile(filePath, os.O_WRONLY|os.O_CREATE, 0666)
	if err != nil {
		return err
	}
	log.Info("生成文件", filePath)
	file.Truncate(0)
	defer file.Close()

	funcMap := template.FuncMap{
		"join":        strings.Join,
		"capUpper":    capUpperString,
		"camelString": camelString,
		"quote":       quoteChar,
	}
	tmpl := template.New("sproto").Delims("<<", ">>")
	tmpl.Funcs(funcMap)
	if tmpl, err := tmpl.Parse(sproto_template); err != nil {
		return err
	} else {
		if err := tmpl.Execute(file, proto); err != nil {
			return err
		}
	}
	return nil
}

func genSprotoGo(genState *gen_state, proto *protocol) error {
	dir := filepath.Join(proj.Config.SrcGenProtocolDir, proto.Module)
	if _, err := os.Stat(proj.Config.SrcGenProtocolDir); os.IsNotExist(err) {
		if err := os.Mkdir(proj.Config.SrcGenProtocolDir, 0755); err != nil {
			return err
		}
	}
	if _, err := os.Stat(dir); os.IsNotExist(err) {
		if err := os.Mkdir(dir, 0755); err != nil {
			return err
		}
	}
	filePath := filepath.Join(dir, fmt.Sprintf("%s.gen.go", proto.Module))
	file, err := os.OpenFile(filePath, os.O_WRONLY|os.O_CREATE, 0644)
	if err != nil {
		return err
	}
	log.Info("生成文件", filePath)
	file.Truncate(0)
	defer file.Close()

	funcMap := template.FuncMap{
		"join":        strings.Join,
		"capUpper":    capUpperString,
		"capLower":    capLowerString,
		"camelString": camelString,
		"quote":       quoteChar,
	}
	tmpl := template.New("sproto").Delims("<<", ">>")
	tmpl.Funcs(funcMap)
	if tmpl, err := tmpl.Parse(sproto_go_template); err != nil {
		return err
	} else {
		if err := tmpl.Execute(file, proto); err != nil {
			return err
		}
	}
	return nil
}

func genSprotoGo2(genState *gen_state, proto *protocol) error {
	dir := filepath.Join(proj.Config.SrcGenProtocolDir, proto.Module)
	if _, err := os.Stat(proj.Config.SrcGenProtocolDir); os.IsNotExist(err) {
		if err := os.Mkdir(proj.Config.SrcGenProtocolDir, 0755); err != nil {
			return err
		}
	}
	if _, err := os.Stat(dir); os.IsNotExist(err) {
		if err := os.Mkdir(dir, 0755); err != nil {
			return err
		}
	}
	filePath := filepath.Join(dir, fmt.Sprintf("%s1.gen.go", proto.Module))
	file, err := os.OpenFile(filePath, os.O_WRONLY|os.O_CREATE, 0644)
	if err != nil {
		return err
	}
	log.Info("生成文件", filePath)
	file.Truncate(0)
	defer file.Close()

	funcMap := template.FuncMap{
		"join":        strings.Join,
		"capUpper":    capUpperString,
		"capLower":    capLowerString,
		"camelString": camelString,
		"quote":       quoteChar,
	}
	tmpl := template.New("sproto").Delims("<<", ">>")
	tmpl.Funcs(funcMap)
	if tmpl, err := tmpl.Parse(sproto_go_template2); err != nil {
		return err
	} else {
		if err := tmpl.Execute(file, proto); err != nil {
			return err
		}
	}
	return nil
}

type Parser interface {
	parse(state *gen_state) error
}

// 生成协议
func Gen() error {
	log.Info("===============gen protocol start===============")

	var p Parser
	if true {
		p = &golang_parser{}
	} else {
		p = &yaml_parser{}
	}
	state := &gen_state{
		protocols: make([]*protocol, 0),
	}
	if err := p.parse(state); err != nil {
		return err
	}
	for _, proto := range state.protocols {
		if err := genSproto(state, proto); err != nil {
			log.Info(err)
			return err
		}

		if err := genSprotoGo(state, proto); err != nil {
			log.Info(err)
			return err
		}

		// if err := genSprotoGo2(state, proto); err != nil {
		// 	log.Info(err)
		// 	return err
		// }
	}
	log.Info("===============gen protocol finished===============")
	return nil
}
